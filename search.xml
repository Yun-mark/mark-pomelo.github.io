<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>关于登录的一切</title>
      <link href="/2022/12/08/%E6%9C%89%E5%85%B3%E7%99%BB%E5%BD%95%E7%9A%84%E4%B8%80%E5%88%87/"/>
      <url>/2022/12/08/%E6%9C%89%E5%85%B3%E7%99%BB%E5%BD%95%E7%9A%84%E4%B8%80%E5%88%87/</url>
      
        <content type="html"><![CDATA[<h1 id="关于登录的一切"><a href="#关于登录的一切" class="headerlink" title="关于登录的一切"></a>关于登录的一切</h1><p>最近在盘点公司的项目源码，第一次真正接触到《单点登录》的实际应用，为了加深理解，便系统性的复习了 “关于登录的一切”，也参考的b站和掘金的优质博主的资料，整理学习笔记。</p><blockquote><p>鸿雁在鱼于在水</p></blockquote><h2 id="前置的知识点"><a href="#前置的知识点" class="headerlink" title="前置的知识点"></a>前置的知识点</h2><ul><li>会使用浏览器控制台查看network</li><li>对通信协议有基本的认识，知道啥是HTTP，甚至居然分得清请求头和响应头</li><li>对登录功能或多或少有过一定的开发经验（小柚智汇）</li><li>模糊的知道cookie的作用和意义</li><li>一知半解的使用过token</li><li>用过第三方登录，思考过它的原理（小医智汇）</li><li>对于登录有一脑袋问号，需要人答疑解惑</li></ul><p><img src="https://images.gitee.com/uploads/images/2021/1113/223659_65958ec1_9194552.png"></p><p>登录，一个页面两个输入框，看起来如此的简单，才导致初学者产生了莫名的自信，想要搞明白关于登录的一切，就先得知道HTTP是什么？</p><h2 id="HTTP的特点"><a href="#HTTP的特点" class="headerlink" title="HTTP的特点"></a>HTTP的特点</h2><p>我们知道，HTTP 是无状态的。也就是说，<strong>HTTP 请求方和响应方间无法维护状态</strong>，都是一次性的，通信完成，链接就会断开。但有的场景下，我们需要维护状态。最典型的，一个用户登陆微博，发布、关注、评论，都应是在登录后的用户状态下的。</p><p><strong>为什么浏览器跟服务器要断开链接呢？</strong></p><p>因为如果长时间保持这个链接，会占用大量的服务器资源，那么服务器能同时服务的客户端数量就会变得很少</p><p><strong>标记</strong></p><p>那解决办法是什么呢？mark对 是我本人~</p><blockquote><p>在学校或公司，入学入职那一天起，会录入你的身份、账户信息，然后给你发个卡，今后在园区内，你的门禁、打卡、消费都只需要刷这张卡。</p></blockquote><p><strong>前端存储</strong></p><p>这就涉及到一发、一存、一带，发好办，登陆接口直接返回给前端，存储就需要前端想办法了。</p><blockquote><p>前提是，你要把卡带在身上。</p></blockquote><p>前端的存储方式有很多。</p><ul><li>最矬的，挂到全局变量上，但这是个「体验卡」，一次刷新页面就没了</li><li>高端点的，存到 cookie、localStorage 等里，这属于「会员卡」，无论怎么刷新，只要浏览器没清掉或者过期，就一直拿着这个状态。</li></ul><p>有地方存了，请求的时候就可以拼到参数里带给接口了。</p><h2 id="基石：cookie"><a href="#基石：cookie" class="headerlink" title="基石：cookie"></a>基石：cookie</h2><blockquote><p>可是前端好麻烦啊，又要自己存，又要想办法带出去，有没有不用操心的？</p></blockquote><p>有，cookie。</p><p>cookie 也是前端存储的一种，但相比于 localStorage 等其他方式，借助 HTTP 头、浏览器能力，cookie 可以做到前端无感知。</p><p>一般过程是这样的：</p><ul><li>在提供标记的接口，通过 HTTP 返回头的 Set-Cookie 字段，直接「种」到浏览器上</li><li>浏览器发起请求时，会自动把 cookie 通过 HTTP 请求头的 Cookie 字段，带给接口</li></ul><p><strong>配置：Domain / Path</strong></p><blockquote><p>你不能拿清华的校园卡进北大。</p></blockquote><p><strong>配置：Expires / Max-Age</strong></p><blockquote><p>你毕业了卡就不好使了。</p></blockquote><p><strong>配置：Secure / HttpOnly</strong></p><blockquote><p>有的学校规定，不带卡套不让刷（什么奇葩学校，假设）；有的学校不让自己给卡贴贴纸。</p></blockquote><p><strong>前端对 cookie 的读写</strong></p><p>前端可以自己创建 cookie，如果服务端创建的 cookie 没加<code>HttpOnly</code>，那恭喜你也可以修改他给的 cookie。</p><p>调用<code>document.cookie</code>可以创建、修改 cookie，和 HTTP 一样，一次<code>document.cookie</code>能且只能操作一个 cookie。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">document</span>.<span class="property">cookie</span> = <span class="string">&#x27;username=jimu; domain=jimu.com; path=/blog; Expires=Wed, 21 Oct 2015 07:28:00 GMT; Secure; HttpOnly&#x27;</span>;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>调用<code>document.cookie</code>也可以读到 cookie，也和 HTTP 一样，能读到所有的非<code>HttpOnly</code> cookie。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">document</span>.<span class="property">cookie</span>);</span><br><span class="line"><span class="comment">// username=jimu; height=180; weight=80</span></span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>（就一个 cookie 属性，为什么读写行为不一样？get / set 了解下）</p><h2 id="cookie在跨越访问时的安全策略"><a href="#cookie在跨越访问时的安全策略" class="headerlink" title="cookie在跨越访问时的安全策略"></a>cookie在跨越访问时的安全策略</h2><p><strong>【samesite:strict】</strong>   此时，浏览器会采用严格禁止的策略。b.com访问a.com时想携带a.com的cookie，任何情况下不允许！</p><p><strong>【samesite:lax】</strong>  浏览器会采用适当禁止的策略。b.com访问a.com时想携带a.com的cookie,那么超链接、预加载、表单get提交是允许的。但如果是图片地址、ajax、iframe这种访问，是禁止携带cookie的。  默认级别</p><p><strong>【samesite:none】</strong> 浏览器没有任何限制。</p><p><strong>cookie 是维持 HTTP 请求状态的基石</strong></p><p>了解了 cookie 后，我们知道 cookie 是最便捷的维持 HTTP 请求状态的方式，大多数前端鉴权问题都是靠 cookie 解决的。当然也可以选用别的存储方式（后面也会多多少少提到）。</p><p>那有了存储工具，接下来怎么做呢？</p><h2 id="应用方案：服务端-session"><a href="#应用方案：服务端-session" class="headerlink" title="应用方案：服务端 session"></a>应用方案：服务端 session</h2><p>现在回想下，你刷卡的时候发生了什么？</p><blockquote><p>其实你的卡上只存了一个 id（可能是你的学号），刷的时候物业系统去查你的信息、账户，再决定「这个门你能不能进」「这个鸡腿去哪个账户扣钱」。</p></blockquote><p>这种操作，在前后端鉴权系统中，叫 session。</p><p>典型的 session 登陆/验证流程：</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/37adb2019d064967923a659848870771~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp" alt="img"></p><ul><li>浏览器登录发送账号密码，服务端查用户库，校验用户</li><li>服务端把用户登录状态存为 Session，生成一个 sessionId</li><li>通过登录接口返回，把 sessionId set 到 cookie 上</li><li>此后浏览器再请求业务接口，sessionId 随 cookie 带上</li><li>服务端查 sessionId 校验 session</li><li>成功后正常做业务处理，返回结果</li></ul><h2 id="token"><a href="#token" class="headerlink" title="token"></a>token</h2><p>session 的维护给服务端造成很大困扰，我们必须找地方存放它，又要考虑分布式的问题，甚至要单独为了它启用一套 Redis 集群。有没有更好的办法？</p><blockquote><p>我又想到学校，在没有校园卡技术以前，我们都靠「学生证」。 门卫小哥直接对照我和学生证上的脸，确认学生证有效期、年级等信息，就可以放行了。</p></blockquote><p>回过头来想想，一个登录场景，也不必往 session 存太多东西，那为什么不直接打包到 cookie 中呢？这样服务端不用存了，每次只要核验 cookie 带的「证件」有效性就可以了，也可以携带一些轻量的信息。</p><p>这种方式通常被叫做 token。</p><p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a1c57a08eb204f528256f3980c721148~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp" alt="img"></p><p>token 的流程是这样的：</p><ul><li>用户登录，服务端校验账号密码，获得用户信息</li><li>把用户信息、token 配置编码成 token，通过 cookie set 到浏览器</li><li>此后用户请求业务接口，通过 cookie 携带 token</li><li>接口校验 token 有效性，进行正常业务接口处理</li></ul><p><strong>客户端 token 的存储方式</strong></p><p>在前面 cookie 说过，cookie 并不是客户端存储凭证的唯一方式。token 因为它的「无状态性」，有效期、使用限制都包在 token 内容里，对 cookie 的管理能力依赖较小，客户端存起来就显得更自由。但 web 应用的主流方式仍是放在 cookie 里，毕竟少操心。</p><p><strong>token 的过期</strong></p><p>那我们如何控制 token 的有效期呢？很简单，把「过期时间」和数据一起塞进去，验证时判断就好。</p><p><strong>Token 的安全性</strong></p><p>安全概览</p><p>为了减少 JWT Token 的泄漏风险，其有效期应该设置得短一些并采用 HTTPS 协议。这样就会存在 JWT Token 过期的情况，导致用户频繁的去登录获取新的 JWT Token，严重影响用户体验</p><p>解决方案</p><p>生成 JWT Token 的同时生成 refresh_token，其中 refresh_token 的有效时间长于 JWT Token，当 JWT Token 过期之后，使用 refresh_token 获取新的 JWT Token 与 refresh_token，这样用户就可以享受无感知的刷新体验</p><h2 id="单点登录"><a href="#单点登录" class="headerlink" title="单点登录"></a>单点登录</h2><p>前面我们已经知道了，在同域下的客户端/服务端认证系统中，通过客户端携带凭证，维持一段时间内的登录状态。</p><p>但当我们业务线越来越多，就会有更多业务系统分散到不同域名下，就需要「一次登录，全线通用」的能力，叫做「单点登录」。</p><p>比如滴滴这么潮的公司，同时拥有<code>didichuxing.com</code> <code>xiaojukeji.com</code> <code>didiglobal.com</code>等域名，种 cookie 是完全绕不开的。</p><p>这要能实现「一次登录，全线通用」，才是真正的单点登录。</p><p>这种场景下，我们需要独立的认证服务，通常被称为 SSO。</p><p><strong>一次「从 A 系统引发登录，到 B 系统不用登录」的完整流程</strong></p><p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/bf2e8ba61fc94b52be164c207b9d8358~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp" alt="img"></p><ul><li>用户进入 A 系统，没有登录凭证（ticket），A 系统给他跳到 SSO</li><li>SSO 没登录过，也就没有 sso 系统下没有凭证（注意这个和前面 A ticket 是两回事），输入账号密码登录</li><li>SSO 账号密码验证成功，通过接口返回做两件事：一是种下 sso 系统下凭证（记录用户在 SSO 登录状态）；二是下发一个 ticket</li><li>客户端拿到 ticket，保存起来，带着请求系统 A 接口</li><li>系统 A 校验 ticket，成功后正常处理业务请求</li><li>此时用户第一次进入系统 B，没有登录凭证（ticket），B 系统给他跳到 SSO</li><li>SSO 登录过，系统下有凭证，不用再次登录，只需要下发 ticket</li><li>客户端拿到 ticket，保存起来，带着请求系统 B 接口</li></ul><h2 id="微信授权登录"><a href="#微信授权登录" class="headerlink" title="微信授权登录"></a>微信授权登录</h2><p>一般使用auth2.0协议</p><p><strong>oauth2.0使用场景</strong></p><h2 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h2><p>假如我有一个网站，你是我网站上的访客，看了文章想留言表示「朕已阅」，留言时发现有这个网站的帐号才能够留言，此时给了你两个选择：一个是在我的网站上注册拥有一个新账户，然后用注册的用户名来留言；一个是使用 github 帐号登录，使用你的 github 用户名来留言。前者你觉得过于繁琐，于是惯性地点击了 github 登录按钮，此时 OAuth 认证流程就开始了。</p><p><img src="https://s3.uuu.ovh/imgs/2022/12/09/ebeeb5041dbd22b2.png" alt="https://s3.uuu.ovh/imgs/2022/12/09/ebeeb5041dbd22b2.png"></p><p>我们看图可以知道，这里最大的问题是，单凭用户的昵称无法区分用户的唯一性，虽然有openid，但openid仅仅对微信有效，如果换成QQ或者微博登录呢？因此，此时的app只是帮你注册了一个临时账号，通常这个时候，app就会不停的催促你绑定手机号，确保唯一性。</p><h2 id="验证码"><a href="#验证码" class="headerlink" title="验证码"></a>验证码</h2><p>通常有两个作用</p><ol><li>防止批量或恶意的提交，干扰平台正常秩序。因此这类会做的比较复杂，比如图片滑动。<img src="https://s3.uuu.ovh/imgs/2022/12/09/5216bdf92591f1a9.png" alt="https://s3.uuu.ovh/imgs/2022/12/09/5216bdf92591f1a9.png"></li><li>第二是为了确保是你本人登录，经常使用的短信验证码。  中间发送短信是最关键的一步。<img src="https://s3.uuu.ovh/imgs/2022/12/09/ab9e091ebd8109a6.png" alt="https://s3.uuu.ovh/imgs/2022/12/09/ab9e091ebd8109a6.png"></li></ol><h2 id="二维码登录"><a href="#二维码登录" class="headerlink" title="二维码登录"></a>二维码登录</h2><p><img src="https://s3.uuu.ovh/imgs/2022/12/09/8783dccb2a91540b.png" alt="https://s3.uuu.ovh/imgs/2022/12/09/8783dccb2a91540b.png"></p><p><strong>本质</strong></p><p>二维码登录本质上也是一种登录认证方式。既然是登录认证，要做的也就两件事情！</p><ol><li>告诉系统我是谁</li><li>向系统证明我是谁</li></ol><p>比如账号密码登录，账号就是告诉系统我是谁， 密码就是向系统证明我是谁; 比如手机验证码登录，手机号就是告诉系统我是谁，验证码就是向系统证明我是谁;</p><p>手机端应用扫PC端二维码，手机端确认后，账号就在PC端登录成功了！这里，PC端登录的账号肯定与手机端是同一个账号。不可能手机端登录的是账号A，而扫码登录以后，PC端登录的是账号B。</p><p>所以，<strong>第一件事情，告诉系统我是谁，是比较清楚的！</strong></p><p>通过扫描二维码，把手机端的账号信息传递到PC端，至于是怎么传的，我们后面再说</p><p><strong>第二件事情，向系统证明我是谁。</strong>扫码登录过程中，用户并没有去输入密码，也没有输入验证码，或者其他什么码。那是怎么证明的呢？</p><p>有些同学会想到，是不是扫码过程中，把密码传到了PC端呢？ 但这是不可能的。因为那样太不安全的，客户端也根本不会去存储密码。我们仔细想一下，其实手机端APP它是已经登录过的，就是说手机端是已经通过登录认证。所说只要<strong>扫码确认是这个手机且是这个账号操作的，其实就能间接证明我谁。</strong></p><p><strong>扫描二维码的大致流程</strong></p><ol><li>扫码前，手机端应用是已登录状态，PC端显示一个二维码，等待扫描</li><li>手机端打开应用，扫描PC端的二维码，扫描后，会提示”已扫描，请在手机端点击确认”</li><li>用户在手机端点击确认，确认后PC端登录就成功了</li></ol><p>可以看到，二维码在中间有三个状态， <strong>待扫描，已扫描待确认，已确认</strong>。 那么可以想象</p><ul><li>二维码的背后它一定存在一个唯一性的ID，当二维码生成时，这个ID也一起生成，并且绑定了PC端的设备信息</li><li>手机去扫描这个二维码</li><li>二维码切换为 已扫描待确认状态， 此时就会将账号信息与这个ID绑定</li><li>当手机端确认登录时，它就会生成PC端用于登录的token，并返回给PC端</li></ul><p><strong>二维码准备</strong></p><p>按二维码不同状态来看， 首先是等待扫描状态，用户打开PC端，切换到二维码登录界面时。</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/74b521bcf35d4215a97a9bea4ae8146d~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.image" alt="1111.jpg"></p><ol><li>PC端向服务端发起请求，告诉服务端，我要生成用户登录的二维码，并且把PC端设备信息也传递给服务端</li><li>服务端收到请求后，它生成二维码ID，并将二维码ID与PC端设备信息进行绑定</li><li>然后把二维码ID返回给PC端</li><li>PC端收到二维码ID后，生成二维码(二维码中肯定包含了ID)</li><li>为了及时知道二维码的状态，客户端在展现二维码后，PC端不断的轮询服务端，比如每隔一秒就轮询一次，请求服务端告诉当前二维码的状态及相关信息</li></ol><p>二维码已经准好了，接下来就是扫描状态</p><p><strong>扫码状态切换</strong></p><ol><li>用户用手机去扫描PC端的二维码，通过二维码内容取到其中的二维码ID</li><li>再调用服务端API将移动端的身份信息与二维码ID一起发送给服务端</li><li>服务端接收到后，它可以将身份信息与二维码ID进行绑定，生成临时token。然后返回给手机端</li><li>因为PC端一直在轮询二维码状态，所以这时候二维码状态发生了改变，它就可以在界面上把二维码状态更新为已扫描</li></ol><p>那么为什么需要返回给手机端一个临时token呢？临时token与token一样，它也是一种身份凭证，不同的地方在于它只能用一次，用过就失效。</p><p>在第三步骤中返回临时token，为的就是手机端在下一步操作时，可以用它作为凭证。以此确保扫码，登录两步操作是同一部手机端发出的，</p><p><strong>状态确认</strong></p><ol><li>手机端在接收到临时token后会弹出确认登录界面，用户点击确认时，手机端携带临时token用来调用服务端的接口，告诉服务端，我已经确认</li><li>服务端收到确认后，根据二维码ID绑定的设备信息与账号信息，生成用户PC端登录的token</li><li>这时候PC端的轮询接口，它就可以得知二维码的状态已经变成了”已确认”。并且从服务端可以获取到用户登录的token</li><li>到这里，登录就成功了</li></ol><p><strong>总结</strong></p><p>PC端通过接口请求生成二维码，二维码信息包括二维码id与设备信息，用户扫码移动端获取二维码id与设备信息，然后移动端将二维码id、PC设备信息、账号发送给服务端，服务端返回给移动端临时token，用户点击移动端确认，将临时token发送给服务端，服务端通过临时token比对扫码与确认是否为同一设备，得知用户已确认，生成PC端token。整个扫码登录过程中，PC端一生成二维码后就会轮询询问二维码状态，从而做出对应的UI变化，PC端得到PC端token即登录成功。</p><h2 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h2><p>我们要搞清楚一切的起因是因为HTTP的无状态性质。</p><blockquote><p>理清概念，一身轻松</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> web前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 交互 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JS性能优化之防抖节流函数</title>
      <link href="/2022/12/05/%E9%98%B2%E6%8A%96/"/>
      <url>/2022/12/05/%E9%98%B2%E6%8A%96/</url>
      
        <content type="html"><![CDATA[<h1 id="JS性能优化之防抖节流函数"><a href="#JS性能优化之防抖节流函数" class="headerlink" title="JS性能优化之防抖节流函数"></a>JS性能优化之防抖节流函数</h1><h2 id="节流"><a href="#节流" class="headerlink" title="节流"></a>节流</h2><h3 id="1-什么是节流"><a href="#1-什么是节流" class="headerlink" title="1.什么是节流"></a>1.什么是节流</h3><p>节流节流就是节省水流、开源节流的意思，就像水龙头在流水，我们可以手动让水流（在一定时间内）小一点，但是他会一直在流。</p><p>就是我们节流的主要目的 其实函数节流，简单地讲，就是<strong>让一个函数无法在很短的时间间隔内连续调用，</strong>只有当上一次函数执行后过了你规定的时间间隔，才能进行下一次该函数的调用。</p><p>就是n秒内只执行一次函数，如果期间多次触发，还是忽略后面的事件，直到第一次事件的计时结束</p><h3 id="2-常见的场景"><a href="#2-常见的场景" class="headerlink" title="2.常见的场景"></a>2.常见的场景</h3><ul><li>王者荣耀平A</li><li>DOM 元素的拖拽功能实现（mousemove）</li><li>搜索联想（keyup）</li><li>计算鼠标移动的距离（mousemove）</li><li>Canvas 模拟画板功能（mousemove）</li><li>射击游戏的 mousedown/keydown 事件（单位时间只能发射一颗子弹）</li></ul><h3 id="3-实现"><a href="#3-实现" class="headerlink" title="3.实现"></a>3.实现</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">throttle</span>(<span class="params">func, delay</span>)&#123;</span><br><span class="line">  <span class="keyword">let</span> timer = <span class="literal">null</span></span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">function</span>(<span class="params">...arg</span>)&#123;</span><br><span class="line">    <span class="comment">// 如果计时器不存在就不再执行后面的事情</span></span><br><span class="line">    <span class="keyword">if</span>(!timer)&#123;</span><br><span class="line">      timer = <span class="built_in">setTimeout</span>(<span class="function">()=&gt;</span>&#123;</span><br><span class="line">        func.<span class="title function_">apply</span>(<span class="variable language_">this</span>, arg)</span><br><span class="line">        <span class="comment">// 就是n秒内只执行一次函数，如果期间多次触发，还是忽略后面的事件，直到第一次事件的计时结束</span></span><br><span class="line">        timer = <span class="literal">null</span></span><br><span class="line">      &#125;, delay)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-使用"><a href="#4-使用" class="headerlink" title="4.使用"></a>4.使用</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> scrollHandler = <span class="title function_">throttle</span>(<span class="keyword">function</span>(<span class="params">e</span>)&#123;</span><br><span class="line">   <span class="variable language_">console</span>.<span class="title function_">log</span>(e);</span><br><span class="line">&#125;,<span class="number">500</span>)</span><br><span class="line"><span class="variable language_">window</span>.<span class="property">onscroll</span> = scrollHandler</span><br></pre></td></tr></table></figure><h2 id="防抖"><a href="#防抖" class="headerlink" title="防抖"></a>防抖</h2><h3 id="1-什么是防抖"><a href="#1-什么是防抖" class="headerlink" title="1.什么是防抖"></a>1.什么是防抖</h3><h3 id="2-场景"><a href="#2-场景" class="headerlink" title="2.场景"></a>2.场景</h3><ul><li>滚动事件</li><li>王者回城</li><li>输入的模糊匹配</li><li>轮播图切换</li></ul><p>浏览器默认情况下都会有总结的监听事件间隔（谷歌：4-6ms），如果监测到多次事件的监听执行，那么就会造成不必要的资源浪费</p><p>对于高频的操作来说，我们只希望识别一次点击，可以任务是第一次或者是最后一次</p><h3 id="3-实现-1"><a href="#3-实现-1" class="headerlink" title="3.实现"></a>3.实现</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* handle 执行函数</span></span><br><span class="line"><span class="comment">* wait 事件触发之后多久开始执行</span></span><br><span class="line"><span class="comment">* immeadite 控制是第一次执行还是最后一次执行</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">        <span class="attr">wait</span>: <span class="number">300</span>,</span><br><span class="line">        <span class="attr">immeadite</span>: <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">myDebounce</span> (handle, obj = obj) &#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="keyword">typeof</span> handle !== <span class="string">&#x27;function&#x27;</span>) &#123;</span><br><span class="line">       <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&#x27;必须传入方法&#x27;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(!obj <span class="keyword">instanceof</span> <span class="title class_">Object</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&#x27;请传入合适的参数&#x27;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">let</span> timer = <span class="literal">null</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">function</span> <span class="title function_">proxy</span> (...args) &#123;</span><br><span class="line">       <span class="keyword">let</span> self = <span class="variable language_">this</span></span><br><span class="line">       <span class="keyword">let</span> init = obj.<span class="property">immeadite</span> &amp;&amp; !timer</span><br><span class="line">       <span class="built_in">clearTimeout</span>(timer)</span><br><span class="line">       timer = <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span>&#123;</span><br><span class="line">             timer = <span class="literal">null</span></span><br><span class="line">            !obj.<span class="property">immeadite</span> &amp;&amp; handle.<span class="title function_">apply</span>(self, args)</span><br><span class="line">        &#125;, obj.<span class="property">wait</span>)</span><br><span class="line">        <span class="comment">// 如果当前传递进来的值 是 true， 那么就表示我们需要立即执行这个函数</span></span><br><span class="line">        <span class="comment">// 如果需要实现在第一次执行，那么添加上 timer 为 null作为判断</span></span><br><span class="line">        <span class="comment">// 因为只要 timer为 null 就以意味着没有第二次点击</span></span><br><span class="line">        init &amp;&amp; handle.<span class="title function_">apply</span>(self, args)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="4-测试使用"><a href="#4-测试使用" class="headerlink" title="4.测试使用"></a>4.测试使用</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&lt;button id=&quot;btn&quot;&gt;计算&lt;/button&gt;</span><br><span class="line">var Btn = document.getElementById(&#x27;btn&#x27;);</span><br><span class="line">   const obj = &#123;</span><br><span class="line">     wait: 300,</span><br><span class="line">     immeadite: false</span><br><span class="line">   &#125;</span><br><span class="line">   function btnclick (a) &#123;</span><br><span class="line">     console.log(&quot;push the button&quot;,a);</span><br><span class="line">   &#125;</span><br><span class="line">   Btn.onclick = myDebounce(btnclick, &#123;</span><br><span class="line">     wait: 3000,</span><br><span class="line">     immeadite: false</span><br><span class="line">   &#125;)</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> web前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 性能优化 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>什么时候不能使用箭头函数？</title>
      <link href="/2022/12/01/JS%E7%9F%A5%E8%AF%86/"/>
      <url>/2022/12/01/JS%E7%9F%A5%E8%AF%86/</url>
      
        <content type="html"><![CDATA[<h2 id="什么时候不能使用箭头函数？"><a href="#什么时候不能使用箭头函数？" class="headerlink" title="什么时候不能使用箭头函数？"></a>什么时候不能使用箭头函数？</h2><h3 id="1-对象方法中，不适用箭头函数"><a href="#1-对象方法中，不适用箭头函数" class="headerlink" title="1. 对象方法中，不适用箭头函数"></a>1. 对象方法中，不适用箭头函数</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&#x27;张三&#x27;</span>,</span><br><span class="line">    <span class="title function_">getName</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">name</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">getName1</span>: <span class="function">() =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">name</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们在对象中定义了<strong>普通函数：getName</strong>和<strong>箭头函数 getName1</strong>，接下来我们来调用一下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;普通函数&#x27;</span>,obj.<span class="title function_">getName</span>())</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;箭头函数&#x27;</span>,obj.<span class="title function_">getName1</span>())</span><br></pre></td></tr></table></figure><p>我们发现箭头函数好像并没有获取到值。</p><h4 id="为什么对象方法中，箭头函数的this指向不是这个对象？"><a href="#为什么对象方法中，箭头函数的this指向不是这个对象？" class="headerlink" title="为什么对象方法中，箭头函数的this指向不是这个对象？"></a>为什么对象方法中，箭头函数的this指向不是这个对象？</h4><ol><li><strong>this 永远指向函数的调用者</strong></li><li>在箭头函数中，<strong>this 指向的是定义时所在的对象，而不是使用时所在的对象</strong>。换句话说，箭头函数没有自己的 this，而是继承父作用域中的 this。</li></ol><p><code>obj.getName()</code>中<code>this</code>指向函数的调用者，也就是<code>obj</code>实例，因此<code>this.name = &quot;张三&quot;</code>。</p><p><code>getName1()</code>通过箭头函数定义，而箭头函数是没有自己的<code>this</code>，会继承父作用域的<code>this</code>。</p><p>因此<code>obj.getName1()</code>执行时，此时的作用域指向<code>window</code>，而<code>window</code>没有定义<code>age</code>属性，所有报空。</p><p>从例子可以得出：<strong>对象中定义的函数使用箭头函数是不合适的</strong>。</p><h3 id="2-原型方法中，不适用箭头函数"><a href="#2-原型方法中，不适用箭头函数" class="headerlink" title="2. 原型方法中，不适用箭头函数"></a>2. 原型方法中，不适用箭头函数</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&#x27;张三&#x27;</span>,</span><br><span class="line">&#125;</span><br><span class="line">obj.<span class="property">__proto__</span>.<span class="property">getName</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">name</span></span><br><span class="line">&#125;</span><br><span class="line">obj.<span class="property">__proto__</span>.<span class="property">getName1</span> = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">name</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们又又又在对象中定义了<strong>普通函数：getName</strong>和<strong>箭头函数 getName1</strong>，接下来我们来调用一下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(obj.<span class="title function_">getName</span>())</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(obj.<span class="title function_">getName1</span>())</span><br></pre></td></tr></table></figure><p><img src="C:\Users\mark\AppData\Roaming\Typora\typora-user-images\image-20221207100935670.png" alt="image-20221207100935670"></p><h4 id="为什么？"><a href="#为什么？" class="headerlink" title="为什么？"></a>为什么？</h4><p>出现问题的原因是this指向window对象，这和使用箭头函数在对象中定义方法十分类似。</p><h3 id="3-构造函数也不行！"><a href="#3-构造函数也不行！" class="headerlink" title="3. 构造函数也不行！"></a>3. 构造函数也不行！</h3><p>我们又又又定义了<strong>普通的构造函数：Foo</strong>和<strong>箭头函数 Foo1</strong>，接下来我们来调用一下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Foo</span> (name, sex) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">name</span> = name</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">sex</span> = sex</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> <span class="title function_">Foo1</span> = (<span class="params">name, sex</span>) =&gt; &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">name</span> = name</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">sex</span> = sex</span><br><span class="line">&#125;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;普通的构造函数：&#x27;</span>, <span class="keyword">new</span> <span class="title class_">Foo</span>(<span class="string">&#x27;张三&#x27;</span>, <span class="string">&#x27;男&#x27;</span>))</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;箭头函数：&#x27;</span>, <span class="keyword">new</span> <span class="title class_">Foo1</span>(<span class="string">&#x27;张三&#x27;</span>, <span class="string">&#x27;男&#x27;</span>))</span><br></pre></td></tr></table></figure><p>不仅不行，还报错了呢！</p><h4 id="为什么？-1"><a href="#为什么？-1" class="headerlink" title="为什么？"></a>为什么？</h4><blockquote><p>构造函数是通过 new 关键字来生成对象实例，生成对象实例的过程也是通过构造函数给实例绑定 this 的过程，而箭头函数没有自己的 this。因此不能使用箭头作为构造函数，也就不能通过 new 操作符来调用箭头函数。</p></blockquote><h3 id="4-动态上下文中的回调函数"><a href="#4-动态上下文中的回调函数" class="headerlink" title="4. 动态上下文中的回调函数"></a>4. 动态上下文中的回调函数</h3><p>比如，我们需要给一个按钮添加点击事件：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> btn1 = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;btn1&#x27;</span>)</span><br><span class="line">btn1.<span class="title function_">addEventListener</span>(<span class="string">&#x27;click&#x27;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">innerHTML</span> = <span class="string">&#x27;clicked&#x27;</span></span><br><span class="line">&#125;)</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>如果我们在回调中不需要使用到 this，那就啥问题也没有，但是！使用到了 this，那么问题就大大的了！</p><h3 id="为什么呢？"><a href="#为什么呢？" class="headerlink" title="为什么呢？"></a>为什么呢？</h3><p><strong>箭头函数的 this 指向的是他的父作用域</strong>（这里就指向了 window），而不是指向这个button。这时候我们需要使用普通函数才可以。</p><h3 id="5-Vue-生命周期和-method-中也不能使用箭头函数"><a href="#5-Vue-生命周期和-method-中也不能使用箭头函数" class="headerlink" title="5. Vue 生命周期和 method 中也不能使用箭头函数"></a>5. Vue 生命周期和 method 中也不能使用箭头函数</h3><p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b60a489f689448cab15b6bf2fa383c4c~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.image" alt="image.png"></p><h4 id="为什么不行呢？"><a href="#为什么不行呢？" class="headerlink" title="为什么不行呢？"></a>为什么不行呢？</h4><p>Vue 本质上是一个对象，我们说过对象方法中，不适用箭头函数。他的本质上的和对象方法中，不适用箭头函数是一样的。</p><p>那么我有一个问题： Vue不行，作为大热框架之一的 react 行吗？</p><p>回答是： react 行</p><p>因为 Vue组件本质上是一个 JS 对象；React 组件（非Hooks）他本质上是一个 ES6 的 class</p><p>不信的话我们测试一下就知道了</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Man</span> &#123;</span><br><span class="line">    <span class="title function_">constructor</span>(<span class="params">name, city</span>) &#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">name</span> = name</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">city</span> = city</span><br><span class="line">    &#125;</span><br><span class="line">    getName = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">name</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> f = <span class="keyword">new</span> <span class="title class_">Man</span>(<span class="string">&#x27;李四&#x27;</span>,<span class="string">&#x27;上海&#x27;</span>)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(f.<span class="title function_">getName</span>())</span><br></pre></td></tr></table></figure><p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ddda17afa8764380918d9077d5d89c93~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.image" alt="image.png"></p><h2 id="SPOT"><a href="#SPOT" class="headerlink" title="SPOT:"></a>SPOT:</h2><ul><li>要熟练使用箭头函数，也要对函数 <strong>this</strong>（重点） 敏感</li><li>Vue组件本质上是一个 JS 对象；React 组件（非Hooks）他本质上是一个 ES6 的 class，两者不同</li></ul>]]></content>
      
      
      <categories>
          
          <category> Js </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Vue相关知识点</title>
      <link href="/2022/11/27/%E7%AC%AC%E4%B8%83d%E7%AF%87%E6%96%87%E7%AB%A0/"/>
      <url>/2022/11/27/%E7%AC%AC%E4%B8%83d%E7%AF%87%E6%96%87%E7%AB%A0/</url>
      
        <content type="html"><![CDATA[<h3 id="Vue的基本原理"><a href="#Vue的基本原理" class="headerlink" title="Vue的基本原理"></a>Vue的基本原理</h3><p>当一个Vue实例创建时，Vue会遍历data中的属性，用 Object.defineProperty（vue3.0使用proxy ）将它们转为 getter/setter，并且在内部追踪相关依赖，在属性被访问和修改时通知变化。 每个组件实例都有相应的 watcher 程序实例，它会在组件渲染的过程中把属性记录为依赖，之后当依赖项的setter被调用时，会通知watcher重新计算，从而致使它关联的组件得以更新。</p><h3 id="双向数据绑定的原理"><a href="#双向数据绑定的原理" class="headerlink" title="双向数据绑定的原理"></a>双向数据绑定的原理</h3><p>Vue.js 是采用<strong>数据劫持</strong>结合<strong>发布者-订阅者模式</strong>的方式，通过Object.defineProperty()来劫持各个属性的setter，getter，在数据变动时发布消息给订阅者，触发相应的监听回调。</p><p>MVVM作为数据绑定的入口，整合Observer、Compile和Watcher三者，通过Observer来监听自己的model数据变化，通过Compile来解析编译模板指令，最终利用Watcher搭起Observer和Compile之间的通信桥梁，达到数据变化 -&gt; 视图更新；视图交互变化(input) -&gt; 数据model变更的双向绑定效果。</p><h3 id="使用-Object-defineProperty-来进行数据劫持有什么缺点？"><a href="#使用-Object-defineProperty-来进行数据劫持有什么缺点？" class="headerlink" title="使用 Object.defineProperty() 来进行数据劫持有什么缺点？"></a>使用 Object.defineProperty() 来进行数据劫持有什么缺点？</h3><p>比如通过下标方式修改数组数据或者给对象新增属性，这都不能触发组件的重新渲染，因为 Object.defineProperty 不能拦截到这些操作。更精确的来说，对于数组而言，大部分操作都是拦截不到的，只是 Vue 内部通过重写函数的方式解决了这个问题。</p><h3 id="MVVM、MVC、MVP的区别"><a href="#MVVM、MVC、MVP的区别" class="headerlink" title="MVVM、MVC、MVP的区别"></a>MVVM、MVC、MVP的区别</h3><p>MVC、MVP 和 MVVM 是三种常见的软件架构设计模式，主要通过分离关注点的方式来组织代码结构，优化开发效率。</p><p>产生背景：页面的渲染、数据的获取，对用户事件的响应所有的应用逻辑都混合在一起，这样在开发简单项目时，可能看不出什么问题，如果项目变得复杂，那么整个文件就会变得冗长、混乱，这样对项目开发和后期的项目维护是非常不利的。</p><p><strong>（1）MVC</strong></p><p>MVC 通过分离 Model、View 和 Controller 的方式来组织代码结构。其中 View 负责页面的显示逻辑，Model 负责存储页面的业务数据，以及对相应数据的操作。并且 View 和 Model 应用了观察者模式，当 Model 层发生改变的时候它会通知有关 View 层更新页面。Controller 层是 View 层和 Model 层的纽带，它主要负责用户与应用的响应操作，</p><p>2）MVVM</p><p>MVVM 分为 Model、View、ViewModel：</p><ul><li>Model代表数据模型，数据和业务逻辑都在Model层中定义；</li><li>View代表UI视图，负责数据的展示；</li><li>ViewModel负责监听Model中数据的改变并且控制视图的更新，处理用户交互操作；</li></ul><p><strong>（3）MVP</strong></p><p>MVP 模式与 MVC 唯一不同的在于 Presenter 和 Controller。</p><p>MVC 中的Controller 只知道 Model 的接口，因此它没有办法控制 View 层的更新，MVP 模式中，View 层的接口暴露给了 Presenter 因此可以在 Presenter 中将 Model 的变化和 View 的变化绑定在一起，以此来实现 View 和 Model 的同步更新。</p><h3 id="Computed-和-Watch-的区别"><a href="#Computed-和-Watch-的区别" class="headerlink" title="Computed 和 Watch 的区别"></a>Computed 和 Watch 的区别</h3><p><strong>对于Computed：</strong></p><p>它支持缓存     购物车结算</p><p> 不支持异步</p><ul><li>如果一个属性是由其他属性计算而来的，这个属性依赖其他的属性，一般会使用computed</li></ul><p><strong>对于Watch：</strong></p><ul><li><p>它不支持缓存，数据变化时，它就会触发相应的操作</p></li><li><p>支持异步监听         搜索数据</p></li><li><p>当一个属性发生变化时，就需要执行相应的操作 </p></li><li><ul><li>immediate：组件加载立即触发回调函数</li><li>deep：深度监听，发现数据内部的变化，在复杂数据类型中使用，例如数组中的对象发生变化。需要注意的是，deep无法监听到数组和对象内部的变化。</li></ul></li></ul><p>当想要执行异步或者昂贵的操作以响应不断的变化时，就需要使用watch。</p><h3 id="Computed-和-Methods-的区别"><a href="#Computed-和-Methods-的区别" class="headerlink" title="Computed 和 Methods 的区别"></a>Computed 和 Methods 的区别</h3><p>可以将同一函数定义为一个 method 或者一个计算属性。对于最终的结果，两种方式是相同的</p><ul><li>computed: 计算属性是基于它们的依赖进行缓存的，只有在它的相关依赖发生改变时才会重新求值；</li><li>method 调用总会执行该函数。</li></ul><h3 id="slot是什么？有什么作用？原理是什么？"><a href="#slot是什么？有什么作用？原理是什么？" class="headerlink" title="slot是什么？有什么作用？原理是什么？"></a>slot是什么？有什么作用？原理是什么？</h3><p>是Vue的内容分发机制，组件内部的模板引擎使用slot元素作为承载分发内容的出口。插槽slot是子组件的一个模板标签元素，而这一个标签元素是否显示，以及怎么显示是由父组件决定的。</p><p>实现原理：当子组件vm实例化时，获取到父组件传入的slot标签的内容，存放在<code>vm.$slot</code>中，默认插槽为<code>vm.$slot.default</code>，具名插槽为<code>vm.$slot.xxx</code>，xxx 为插槽名，当组件执行渲染函数时候，遇到slot标签，使用<code>$slot</code>中的内容进行替换，此时可以为插槽传递数据，若存在数据，则可称该插槽为作用域插槽。</p><h3 id="如何保存页面的当前的状态"><a href="#如何保存页面的当前的状态" class="headerlink" title="如何保存页面的当前的状态"></a>如何保存页面的当前的状态</h3><p><strong>（1）将状态存储在LocalStorage / SessionStorage</strong></p><p><strong>优点：</strong></p><ul><li>兼容性好，不需要额外库或工具。</li><li>简单快捷，基本可以满足大部分需求。</li></ul><p><strong>缺点：</strong></p><ul><li>状态通过 JSON 方法储存（相当于深拷贝），如果状态中有特殊情况（比如 Date 对象、Regexp 对象等）的时候会得到字符串而不是原来的值。（具体参考用 JSON 深拷贝的缺点）</li><li>如果 B 组件后退或者下一页跳转并不是前组件，那么 flag 判断会失效，导致从其他页面进入 A 组件页面时 A 组件会重新读取 Storage，会造成很奇怪的现象</li></ul><p><strong>（2）路由传值</strong></p><p><strong>优点：</strong></p><ul><li>简单快捷，不会污染 LocalStorage / SessionStorage。</li><li>可以传递 Date、RegExp 等特殊对象（不用担心 JSON.stringify / parse 的不足）</li></ul><p><strong>缺点：</strong></p><ul><li>如果 A 组件可以跳转至多个组件，那么在每一个跳转组件内都要写相同的逻辑。</li></ul><h3 id="常见的事件修饰符及其作用"><a href="#常见的事件修饰符及其作用" class="headerlink" title="常见的事件修饰符及其作用"></a>常见的事件修饰符及其作用</h3><p><code>.stop</code>：等同于 JavaScript 中的 <code>event.stopPropagation()</code> ，防止事件冒泡；</p><p><code>.prevent</code> ：等同于 JavaScript 中的 <code>event.preventDefault()</code> ，防止执行预设的行为（如果事件可取消，则取消该事件，而不停止事件的进一步传播）；</p><p><code>.capture</code> ：与事件冒泡的方向相反，事件捕获由外到内；</p><p><code>.self</code> ：只会触发自己范围内的事件，不包含子元素；</p><p><code>.once</code> ：只会触发一次。</p><h3 id="v-if、v-show、v-html-的原理"><a href="#v-if、v-show、v-html-的原理" class="headerlink" title="v-if、v-show、v-html 的原理"></a>v-if、v-show、v-html 的原理</h3><p>v-if会调用addIfCondition方法，生成vnode的时候会忽略对应节点，render的时候就不会渲染；</p><p>v-show会生成vnode，render的时候也会渲染成真实节点，只是在render过程中会在节点的属性中修改show属性值，也就是常说的display；</p><p>v-html会先移除节点下的所有节点，调用html方法，通过addProp添加innerHTML属性，归根结底还是设置innerHTML为v-html的值。</p><h3 id="v-if和v-show的区别"><a href="#v-if和v-show的区别" class="headerlink" title="v-if和v-show的区别"></a>v-if和v-show的区别</h3><p><strong>手段</strong>：v-if是动态的向DOM树内添加或者删除DOM元素；v-show是通过设置DOM元素的display样式属性控制显隐；</p><p><strong>编译过程</strong>：v-if切换有一个局部编译/卸载的过程，切换过程中合适地销毁和重建内部的事件监听和子组件；v-show只是简单的基于css切换；</p><p><strong>编译条件</strong>：v-if是惰性的，如果初始条件为假，则什么也不做；只有在条件第一次变为真时才开始局部编译; v-show是在任何条件下，无论首次条件是否为真，都被编译，然后被缓存，而且DOM元素保留；</p><p><strong>性能消耗</strong>：v-if有更高的切换消耗；v-show有更高的初始渲染消耗；</p><p><strong>使用场景</strong>：v-if适合运营条件不大可能改变；v-show适合频繁切换。</p><h3 id="v-model-是如何实现的，语法糖实际是什么？"><a href="#v-model-是如何实现的，语法糖实际是什么？" class="headerlink" title="v-model 是如何实现的，语法糖实际是什么？"></a>v-model 是如何实现的，语法糖实际是什么？</h3><p>在input 上绑定message，并通过input事件获取当前事件的target.value，并赋值给message</p><h3 id="data为什么是一个函数而不是对象"><a href="#data为什么是一个函数而不是对象" class="headerlink" title="data为什么是一个函数而不是对象"></a>data为什么是一个函数而不是对象</h3><p>组件的数据不能写成对象的形式，而是要写成函数的形式。数据以函数返回值的形式定义，这样当每次复用组件的时候，就会返回一个新的data，也就是说每个组件都有自己的私有数据空间，它们各自维护自己的数据，不会干扰其他组件的正常运行。</p><h3 id="对keep-alive的理解，它是如何实现的，具体缓存的是什么？"><a href="#对keep-alive的理解，它是如何实现的，具体缓存的是什么？" class="headerlink" title="对keep-alive的理解，它是如何实现的，具体缓存的是什么？"></a>对keep-alive的理解，它是如何实现的，具体缓存的是什么？</h3><p><strong>主要流程</strong></p><ol><li>判断组件 name ，不在 include 或者在 exclude 中，直接返回 vnode，说明该组件不被缓存。</li><li>获取组件实例 key ，如果有获取实例的 key，否则重新生成。</li><li>key生成规则，cid +”∶∶”+ tag ，仅靠cid是不够的，因为相同的构造函数可以注册为不同的本地组件。</li><li>如果缓存对象内存在，则直接从缓存对象中获取组件实例给 vnode ，不存在则添加到缓存对象中。 5.最大缓存数量，当缓存组件数量超过 max 值时，清除 keys 数组内第一个组件。</li></ol><h3 id="nextTick-原理及作用"><a href="#nextTick-原理及作用" class="headerlink" title="$nextTick 原理及作用"></a>$nextTick 原理及作用</h3><p>本质是对 JavaScript 执行原理 EventLoop 的一种应用。本质是为了利用 JavaScript 的这些异步回调任务队列来实现 Vue 框架中自己的异步回调队列。</p><p>DOM1的数据发生了变化，而DOM2需要从DOM1中获取数据，那这时就会发现DOM2的视图并没有更新，这时就需要用到了<code>nextTick</code>了。在vue生命周期中，如果在created()钩子进行DOM操作，也一定要放在<code>nextTick()</code>的回调函数中。</p><h3 id="Vue-中给-data-中的对象属性添加一个新的属性时会发生什么？如何解决？"><a href="#Vue-中给-data-中的对象属性添加一个新的属性时会发生什么？如何解决？" class="headerlink" title="Vue 中给 data 中的对象属性添加一个新的属性时会发生什么？如何解决？"></a><strong>Vue 中给 data 中的对象属性添加一个新的属性时会发生什么？如何解决？</strong></h3><p>点击 button 会发现，obj.b 已经成功添加，但是视图并未刷新。这是因为在Vue实例创建时，obj.b并未声明，因此就没有被Vue转换为响应式的属性，自然就不会触发视图的更新，这时就需要使用Vue的全局 api <strong>$set()：</strong></p><p>$set()方法相当于手动的去把obj.b处理成一个响应式的属性，此时视图也会跟着改变了。</p><h3 id="Vue中封装的数组方法有哪些，其如何实现页面更新"><a href="#Vue中封装的数组方法有哪些，其如何实现页面更新" class="headerlink" title="Vue中封装的数组方法有哪些，其如何实现页面更新"></a>Vue中封装的数组方法有哪些，其如何实现页面更新</h3><p>简单来说就是，重写了数组中的那些原生方法，首先获取到这个数组的__ob__，也就是它的Observer对象，如果有新的值，就调用observeArray继续对新的值观察变化（也就是通过<code>target__proto__ == arrayMethods</code>来改变了数组实例的型），然后手动调用notify，通知渲染watcher，执行update。</p><h3 id="Vue-template-到-render-的过程"><a href="#Vue-template-到-render-的过程" class="headerlink" title="Vue template 到 render 的过程"></a>Vue template 到 render 的过程</h3><p><strong>template -&gt; ast -&gt; render函数</strong></p><p>CompileToFunctions中的主要逻辑如下∶ </p><p><strong>（1）调用parse方法将template转化为ast（抽象语法树）</strong></p><p><strong>（2）对静态节点做优化</strong></p><p><strong>（3）生成代码</strong></p><h3 id="Vue-data-中某一个属性的值发生改变后，视图会立即同步执行重新渲染吗？"><a href="#Vue-data-中某一个属性的值发生改变后，视图会立即同步执行重新渲染吗？" class="headerlink" title="Vue data 中某一个属性的值发生改变后，视图会立即同步执行重新渲染吗？"></a>Vue data 中某一个属性的值发生改变后，视图会立即同步执行重新渲染吗？</h3><p>不会立即同步执行重新渲染。Vue 实现响应式并不是数据发生变化之后 DOM 立即变化，而是按一定的策略进行 DOM 的更新。Vue 在更新 DOM 时是异步执行的。只要侦听到数据变化， Vue 将开启一个队列，并缓冲在同一事件循环中发生的所有数据变更。</p><p>如果同一个watcher被多次触发，只会被推入到队列中一次。</p><h3 id="子组件可以直接改变父组件的数据吗？"><a href="#子组件可以直接改变父组件的数据吗？" class="headerlink" title="子组件可以直接改变父组件的数据吗？"></a>子组件可以直接改变父组件的数据吗？</h3><p>子组件不可以直接改变父组件的数据。这样做主要是为了维护父子组件的单向数据流。每次父级组件发生更新时，子组件中所有的 prop 都将会刷新为最新的值。</p><p>这是为了防止意外的改变父组件状态，使得应用的数据流变得难以理解，导致数据流混乱。</p><h3 id="对-React-和-Vue-的理解，它们的异同"><a href="#对-React-和-Vue-的理解，它们的异同" class="headerlink" title="对 React 和 Vue 的理解，它们的异同"></a>对 React 和 Vue 的理解，它们的异同</h3><p><strong>相似之处：</strong></p><ul><li>都将注意力集中保持在核心库，而将其他功能如路由和全局状态管理交给相关的库；</li><li>都有自己的构建工具，能让你得到一个根据最佳实践设置的项目模板；</li><li>都使用了Virtual DOM（虚拟DOM）提高重绘性能；</li><li>都有props的概念，允许组件间的数据传递；</li><li>都鼓励组件化应用，将应用分拆成一个个功能明确的模块，提高复用性。</li></ul><p><strong>不同之处 ：</strong></p><p><strong>1）数据流</strong></p><p>Vue默认支持数据双向绑定，而React一直提倡单向数据流</p><p><strong>2）虚拟DOM</strong></p><ul><li><p>Vue宣称可以更快地计算出Virtual DOM的差异，这是由于它在渲染过程中，会跟踪每一个组件的依赖关系，不需要重新渲染整个组件树。</p></li><li><p>对于React而言，每当应用的状态被改变时，全部子组件都会重新渲染。当然，这可以通过 PureComponent/shouldComponentUpdate这个生命周期方法来进行控制，但Vue将此视为默认的优化。</p></li></ul><p><strong>3）组件化</strong></p><ul><li><p>Vue鼓励写近似常规HTML的模板。写起来很接近标准 HTML元素，只是多了一些属性。</p></li><li><p>React推荐你所有的模板通用JavaScript的语法扩展——JSX书写。</p></li></ul><p><strong>4）监听数据变化的实现原理不同</strong></p><ul><li>Vue 通过 getter/setter 以及一些函数的劫持，能精确知道数据变化，不需要特别的优化就能达到很好的性能</li></ul><p>React 默认是通过比较引用的方式进行的，如果不优化（PureComponent/shouldComponentUpdate）可能导致大量不必要的vDOM的重新渲染。</p><p><strong>5）高阶组件</strong></p><p>react可以通过高阶组件（HOC）来扩展，而Vue需要通过mixins来扩展。</p><p>高阶组件就是高阶函数，而React的组件本身就是纯粹的函数，所以高阶函数对React来说易如反掌。相反Vue.js使用HTML模板创建视图组件，这时模板无法有效的编译，因此Vue不能采用HOC来实现。</p><p><strong>7）跨平台</strong></p><ul><li>React ==&gt; React Native</li><li>Vue ==&gt; Weex</li></ul><h3 id="Vue的优点"><a href="#Vue的优点" class="headerlink" title="Vue的优点"></a>Vue的优点</h3><p>轻量级框架：只关注视图层，是一个构建数据的视图集合，大小只有几十 <code>kb</code> ；</p><p>简单易学：国人开发，中文文档，不存在语言障碍 ，易于理解和学习；</p><p>双向数据绑定：保留了 <code>angular</code> 的特点，在数据操作方面更为简单；</p><p>组件化：保留了 <code>react</code> 的优点，实现了 <code>html</code> 的封装和重用，在构建单页面应用方面有着独特的优势；</p><p>视图，数据，结构分离：使数据的更改更为简单，不需要进行逻辑代码的修改，只需要操作数据就能完成相关操作；</p><p>虚拟DOM：<code>dom</code> 操作是非常耗费性能的，不再使用原生的 <code>dom</code> 操作节点，极大解放 <code>dom</code> 操作，但具体操作的还是 <code>dom</code> 不过是换了另一种方式；</p><p>运行速度更快：相比较于 <code>react</code> 而言，同样是操作虚拟 <code>dom</code>，就性能而言， <code>vue</code> 存在很大的优势。</p><h3 id="delete和Vue-delete删除数组的区别"><a href="#delete和Vue-delete删除数组的区别" class="headerlink" title="delete和Vue.delete删除数组的区别"></a>delete和Vue.delete删除数组的区别</h3><ul><li><code>delete</code> 只是被删除的元素变成了 <code>empty/undefined</code> 其他的元素的键值还是不变。</li><li><code>Vue.delete</code> 直接删除了数组 改变了数组的键值。</li></ul><p><strong>vm.<code>$set</code> 的实现原理是：</strong></p><p>如果目标是数组，直接使用数组的 splice 方法触发相应式；</p><p>如果目标是对象，会先判读属性是否存在、对象是否是响应式，最终如果要对属性进行响应式处理，则是通过调用 defineReactive 方法进行响应式处理（ defineReactive 方法就是 Vue 在初始化对象时，给对象属性采用 Object.defineProperty 动态添加 getter 和 setter 的功能所调用的方法）</p><h3 id="Vue模版编译原理"><a href="#Vue模版编译原理" class="headerlink" title="Vue模版编译原理"></a>Vue模版编译原理</h3><p><strong>解析阶段</strong>：使用大量的正则表达式对template字符串进行解析，将标签、指令、属性等转化为抽象语法树AST。</p><p><strong>优化阶段</strong>：遍历AST，找到其中的一些静态节点并进行标记，方便在页面重渲染的时候进行diff比较时，直接跳过这一些静态节点，优化runtime的性能。</p><p><strong>生成阶段</strong>：将最终的AST转化为render函数字符串。</p><h3 id="Vue的性能优化有哪些"><a href="#Vue的性能优化有哪些" class="headerlink" title="Vue的性能优化有哪些"></a>Vue的性能优化有哪些</h3><p><strong>（1）编码阶段</strong></p><ul><li>尽量减少data中的数据，data中的数据都会增加getter和setter，会收集对应的watcher</li><li>v-if和v-for不能连用</li><li>如果需要使用v-for给每项元素绑定事件时使用事件代理</li><li>SPA 页面采用keep-alive缓存组件</li><li>在更多的情况下，使用v-if替代v-show</li><li>key保证唯一</li><li>使用路由懒加载、异步组件</li><li>防抖、节流</li><li>第三方模块按需导入</li><li>长列表滚动到可视区域动态加载</li><li>图片懒加载</li></ul><p><strong>（2）SEO优化</strong></p><ul><li>预渲染</li><li>服务端渲染SSR</li></ul><p><strong>（3）打包优化</strong></p><ul><li>压缩代码</li><li>Tree Shaking/Scope Hoisting</li><li>使用cdn加载第三方模块</li><li>多线程打包happypack</li><li>splitChunks抽离公共文件</li><li>sourceMap优化</li></ul><p><strong>（4）用户体验</strong></p><ul><li>骨架屏</li><li>PWA</li><li>还可以使用缓存(客户端缓存、服务端缓存)优化、服务端开启gzip压缩等。</li></ul><h3 id="说一下Vue的生命周期"><a href="#说一下Vue的生命周期" class="headerlink" title="说一下Vue的生命周期"></a>说一下Vue的生命周期</h3><p>Vue 实例有⼀个完整的⽣命周期，也就是从开始创建、初始化数据、编译模版、挂载Dom -&gt; 渲染、更新 -&gt; 渲染、卸载 等⼀系列过程，称这是Vue的⽣命周期。</p><h3 id="Vue-子组件和父组件执行顺序"><a href="#Vue-子组件和父组件执行顺序" class="headerlink" title="Vue 子组件和父组件执行顺序"></a>Vue 子组件和父组件执行顺序</h3><p><strong>加载渲染过程：</strong></p><ol><li>父组件 beforeCreate</li><li>父组件 created</li><li>父组件 beforeMount</li><li>子组件 beforeCreate</li><li>子组件 created</li><li>子组件 beforeMount</li><li>子组件 mounted</li><li>父组件 mounted</li></ol><h3 id="created和mounted的区别"><a href="#created和mounted的区别" class="headerlink" title="created和mounted的区别"></a>created和mounted的区别</h3><ul><li>created:在模板渲染成html前调用，即通常初始化某些属性值，然后再渲染成视图。</li><li>mounted:在模板渲染成html后调用，通常是初始化页面完成后，再对html的dom节点进行一些需要的操作。</li></ul><h2 id="组件通信"><a href="#组件通信" class="headerlink" title="组件通信"></a>组件通信</h2><h3 id="（1）-props-emit"><a href="#（1）-props-emit" class="headerlink" title="（1） props  /  $emit"></a>（1） props  /  $emit</h3><p>父组件通过<code>props</code>向子组件传递数据，子组件通过<code>$emit</code>和父组件通信</p><h3 id="（2）eventBus事件总线（-emit-on）"><a href="#（2）eventBus事件总线（-emit-on）" class="headerlink" title="（2）eventBus事件总线（$emit / $on）"></a>（2）eventBus事件总线（<code>$emit / $on</code>）</h3><p><strong>（1）创建事件中心管理组件之间的通信</strong></p><p><strong>（2）发送事件</strong></p><p><strong>（3）接收事件</strong></p><p>虽然看起来比较简单，但是这种方法也有不变之处，如果项目过大，使用这种方式进行通信，后期维护起来会很困难。</p><h3 id="（3）依赖注入（provide-inject）"><a href="#（3）依赖注入（provide-inject）" class="headerlink" title="（3）依赖注入（provide / inject）"></a>（3）依赖注入（provide / inject）</h3><p>该方法用于<strong>父子组件之间的通信</strong>。当然这里所说的父子不一定是真正的父子，也可以是祖孙组件，在层数很深的情况下，可以使用这种方法来进行传值</p><p>依赖注入所提供的属性是<strong>非响应式</strong>的。</p><h3 id="（4）ref-refs"><a href="#（4）ref-refs" class="headerlink" title="（4）ref / $refs"></a>（4）ref / $refs</h3><p>这种方式也是实现<strong>父子组件</strong>之间的通信。</p><p><code>ref</code>： 这个属性用在子组件上，它的引用就指向了子组件的实例。可以通过实例来访问组件的数据和方法。</p><h3 id="（5）-parent-children"><a href="#（5）-parent-children" class="headerlink" title="（5）$parent / $children"></a>（5）<code>$parent / $children</code></h3><ul><li><p>使用<code>$parent</code>可以让组件访问父组件的实例（访问的是上一级父组件的属性和方法）</p></li><li><p>使用<code>$children</code>可以让组件访问子组件的实例，但是，<code>$children</code>并不能保证顺序，并且访问的数据也不是响应式的。</p></li><li><p><code>$children</code> 的值是<strong>数组</strong>，而<code>$parent</code>是个<strong>对象</strong></p></li></ul><h3 id="（6）-attrs-listeners"><a href="#（6）-attrs-listeners" class="headerlink" title="（6）$attrs / $listeners"></a>（6）<code>$attrs / $listeners</code></h3><p>如果想要组件A给组件C传递数据，这种隔代的数据，该使用哪种方式呢？实现组件之间的跨代通信。</p><ul><li>C组件中能直接触发test的原因在于 B组件调用C组件时 使用 v-on 绑定了<code>$listeners</code> 属性</li></ul><h3 id="vuex"><a href="#vuex" class="headerlink" title="vuex"></a>vuex</h3><p><strong>那 Vuex 解决了什么问题呢？</strong></p><ul><li>管理多个组件共享状态。</li><li>全局状态管理。</li><li>状态变更跟踪。</li><li>让状态管理形成一种规范，使代码结构更清晰。</li></ul><p><strong>那问题来了，既然你的目的只是共享多个状态，那何不直接用 Bus 总线好了？</strong></p><p>怎么样？上面对于满足共享一个状态是不是比 Vuex 要简单多了？实际上确实是简单多了，但这也代表他比较适合中小型项目。多于大型项目来说 Bus 只会让你追述更改源时一脸懵逼甚至你都不知道他在哪里改变了。</p>]]></content>
      
      
      <categories>
          
          <category> vue </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Vue </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>浏览器原理篇</title>
      <link href="/2022/11/23/%E7%AC%AC%E5%85%AD%E7%AF%87%E6%96%87%E7%AB%A0/"/>
      <url>/2022/11/23/%E7%AC%AC%E5%85%AD%E7%AF%87%E6%96%87%E7%AB%A0/</url>
      
        <content type="html"><![CDATA[<h3 id="什么是-XSS-攻击？"><a href="#什么是-XSS-攻击？" class="headerlink" title="什么是 XSS 攻击？"></a>什么是 XSS 攻击？</h3><p>XSS 攻击指的是跨站脚本攻击，是一种代码注入攻击。攻击者通过在网站注入恶意脚本，使之在用户的浏览器上运行，从而盗取用户的信息如 cookie 等。</p><p>XSS 可以分为存储型、反射型和 DOM 型：</p><p>反射型 XSS 跟存储型 XSS 的区别是：存储型 XSS 的恶意代码存在数据库⾥，反射型 XSS 的恶意代码存在 URL ⾥。</p><p>DOM 型 XSS 跟前两种 XSS 的区别：DOM 型 XSS 攻击中，取出和执⾏恶意代码由浏览器端完成，属于前端JavaScript ⾃身的安全漏洞，⽽其他两种 XSS 都属于服务端的安全漏洞。</p><h3 id="如何防御-XSS-攻击？"><a href="#如何防御-XSS-攻击？" class="headerlink" title="如何防御 XSS 攻击？"></a>如何防御 XSS 攻击？</h3><ul><li>对一些敏感信息进行保护，比如 cookie 使用 http-only，使得脚本无法获取。也可以使用验证码，避免脚本伪装成用户执行一些操作。</li></ul><p>​    可以从浏览器的执行来进行预防，一种是使用纯前端的方式，不用服务器端拼接后返回（不使用服务端渲染）。</p><h3 id="什么是-CSRF-攻击？"><a href="#什么是-CSRF-攻击？" class="headerlink" title="什么是 CSRF 攻击？"></a>什么是 CSRF 攻击？</h3><p>CSRF 攻击的<strong>本质是利用 cookie 会在同源请求中携带发送给服务器的特点，以此来实现用户的冒充。</strong></p><h3 id="如何防御-CSRF-攻击？"><a href="#如何防御-CSRF-攻击？" class="headerlink" title="如何防御 CSRF 攻击？"></a>如何防御 CSRF 攻击？</h3><p><strong>进行同源检测</strong>，服务器根据 http 请求头中 origin 或者 referer 信息来判断请求是否为允许访问的站点，从而对请求进行过滤。</p><p><strong>使用 CSRF Token 进行验证</strong>，服务器向用户返回一个随机数 Token ，当网站再次发起请求时，在请求参数中加入服务器端返回的 token ，然后服务器对这个 token 进行验证。</p><p><strong>在设置 cookie 属性的时候设置 Samesite ，限制 cookie 不能作为被第三方使用</strong>，从而可以避免被攻击者利用。</p><p>SameSite 属性有三个枚举值，分别是 strict/lax/none。</p><p>就像对抗疫情一样，Web 安全治理需要整个行业技术生态的支持，从这个角度看，我们互联网技术人应该积极响应和支持 Google 的这个策略。</p><h3 id="网络劫持有哪几种，如何防范？"><a href="#网络劫持有哪几种，如何防范？" class="headerlink" title="网络劫持有哪几种，如何防范？"></a>网络劫持有哪几种，如何防范？</h3><p><strong>DNS劫持</strong>: (输⼊京东被强制跳转到淘宝这就属于dns劫持) 通过修改运营商的本地DNS记录，来引导⽤户流量到缓存服务器</p><p><strong>HTTP劫持</strong>: (访问⾕歌但是⼀直有贪玩蓝⽉的⼴告),由于http明⽂传输,运营商会修改你的http响应内容(即加⼴告)</p><p>DNS劫持由于涉嫌违法，已经被监管起来，现在很少会有DNS劫持，⽽http劫持依然⾮常盛⾏，最有效的办法就是全站HTTPS，将HTTP加密，这使得运营商⽆法获取明⽂，就⽆法劫持你的响应内容。</p><h3 id="进程与线程的概念"><a href="#进程与线程的概念" class="headerlink" title="进程与线程的概念"></a>进程与线程的概念</h3><p><strong>进程是资源分配的最小单位，线程是CPU调度的最小单位</strong></p><p>启动一个程序的时候，操作系统会为该程序创建一块内存，用来存放代码、运行中的数据和一个执行任务的主线程，我们把这样的一个运行环境叫<strong>进程</strong>。</p><p>进程是运行在虚拟内存上的，虚拟内存是用来解决用户对硬件资源的无限需求和有限的硬件资源之间的矛盾的。从操作系统角度来看，虚拟内存即交换文件；从处理器角度看，虚拟内存即虚拟地址空间。</p><p><strong>打开一个网页，最少需要四个进程</strong>：1 个网络进程、1 个浏览器进程、1 个 GPU 进程以及 1 个渲染进程。如果打开的页面有运行插件的话，还需要再加上 1 个插件进程。</p><h3 id="如何理解高内聚低耦合"><a href="#如何理解高内聚低耦合" class="headerlink" title="如何理解高内聚低耦合"></a>如何理解高内聚低耦合</h3><p>通常程序结构中各模块的内聚程度越高，模块间的耦合程度就越低。</p><p>内聚是从功能角度来度量模块内的联系，一个好的内聚模块应当恰好做一件事，它描述的是模块内的功能联系；耦合是软件结构中各模块之间相互连接的一种<a href="https://baike.baidu.com/item/%E5%BA%A6%E9%87%8F/34036">度量</a>，耦合强弱取决于模块间接口的复杂程度、进入或访问一个模块的点以及通过接口的数据。</p><h3 id="进程和线程的区别"><a href="#进程和线程的区别" class="headerlink" title="进程和线程的区别"></a>进程和线程的区别</h3><ul><li><p>进程可以看做独立应用，线程不能</p></li><li><p>资源：进程是cpu资源分配的最小单位（是能拥有资源和独立运行的最小单位）；线程是cpu调度的最小单位（线程是建立在进程的基础上的一次程序运行单位，一个进程中可以有多个线程）。</p></li><li><p>通信方面：线程间可以通过直接共享同一进程中的资源，而进程通信需要借助 进程间通信。</p></li><li><p>系统开销：由于创建或撤销进程时，系统都要为之分配或回收资源，如内存、I/O 等，其开销远大于创建或撤销线程时的开销。</p></li><li><p>同理，在进行进程切换时，涉及当前执行进程 CPU 环境还有各种各样状态的保存及新调度进程状态的设置，而线程切换时只需保存和设置少量寄存器内容，开销较小</p></li></ul><h3 id="浏览器渲染进程的线程有哪些"><a href="#浏览器渲染进程的线程有哪些" class="headerlink" title="浏览器渲染进程的线程有哪些"></a>浏览器渲染进程的线程有哪些</h3><p><strong>（1）GUI渲染线程</strong></p><p><strong>（2）JS引擎线程</strong></p><p><strong>（3）时间触发线程</strong> </p><p><strong>（4）定时器触发进程</strong> </p><p><strong>（5）异步http请求线程</strong>                                                                   </p><h3 id="进程之间的通信方式"><a href="#进程之间的通信方式" class="headerlink" title="进程之间的通信方式"></a>进程之间的通信方式</h3><p><strong>（1）管道通信</strong></p><p>管道是一种最基本的进程间通信机制。<strong>管道就是操作系统在内核中开辟的一段缓冲区，进程1可以将需要交互的数据拷贝到这段缓冲区，进程2就可以读取了。</strong></p><p>管道的特点：</p><ul><li>只能单向通信</li><li>只能血缘关系的进程进行通信</li><li>依赖于文件系统</li></ul><p><strong>（2）消息队列通信</strong></p><p>消息队列提供了一种从一个进程向另一个进程发送一个数据块的方法。 每个数据块都被认为含有一个类型，接收进程可以独立地接收含有不同类型的数据结构。可以通过发送消息来避免命名管道的同步和阻塞问题。但是消息队列与命名管道一样，每个数据块都有一个最大长度的限制。</p><p>可能会收到数据块最大长度的限制约束等，这也是这种通信方式的缺点。</p><p><strong>（3）共享内存通信</strong></p><p>共享内存就是映射一段能被其他进程所访问的内存，这段共享内存由一个进程创建，但多个进程都可以访问（使多个进程可以访问同一块内存空间）。</p><p>共享内存是最快的 IPC 方式，它是针对其他进程间通信方式运行效率低而专门设计的。它往往与其他通信机制，如信号量，配合使用，来实现进程间的同步和通信</p><p><strong>（4）信号量通信</strong></p><p>信号量的本质就是一个计数器，用来实现进程之间的互斥与同步。例如信号量的初始值是 1，然后 a 进程来访问内存1的时候，我们就把信号量的值设为 0，然后进程b 也要来访问内存1的时候，看到信号量的值为 0 就知道已经有进程在访问内存1了，这个时候进程 b 就会访问不了内存1。所以说，信号量也是进程之间的一种通信方式。</p><p><strong>（5）套接字通信</strong></p><p>上面说的共享内存、管道、信号量、消息队列，他们都是多个进程在一台主机之间的通信，那两个相隔几千里的进程能够进行通信吗？答是必须的，这个时候 Socket 这家伙就派上用场了，例如我们平时通过浏览器发起一个 http 请求，然后服务器给你返回对应的数据，这种就是采用 Socket 的通信方式了。</p><h3 id="僵尸进程和孤儿进程是什么？"><a href="#僵尸进程和孤儿进程是什么？" class="headerlink" title="僵尸进程和孤儿进程是什么？"></a>僵尸进程和孤儿进程是什么？</h3><ul><li><p><strong>孤儿进程</strong>：父进程退出了，而它的一个或多个进程还在运行，那这些子进程都会成为孤儿进程。孤儿进程将被init进程(进程号为1)所收养，并由init进程对它们完成状态收集工作。</p></li><li><p><strong>僵尸进程</strong>：子进程比父进程先结束，而父进程又没有释放子进程占用的资源，那么子进程的进程描述符仍然保存在系统中，这种进程称之为僵死进程。</p></li></ul><h3 id="死锁产生的原因？-如何解决死锁的问题？"><a href="#死锁产生的原因？-如何解决死锁的问题？" class="headerlink" title="死锁产生的原因？ 如何解决死锁的问题？"></a>死锁产生的原因？ 如何解决死锁的问题？</h3><p><strong>多个进程在运行过程中因争夺资源而造成的一种僵局</strong></p><p><strong>产生死锁的原因：</strong></p><p><strong>（1）竞争资源</strong></p><ul><li>产生死锁中的竞争资源之一指的是<strong>竞争不可剥夺资源</strong>（例如：系统中只有一台打印机，可供进程P1使用，假定P1已占用了打印机，若P2继续要求打印机打印将阻塞）</li><li>产生死锁中的竞争资源另外一种资源指的是<strong>竞争临时资源</strong>（临时资源包括硬件中断、信号、消息、缓冲区内的消息等），通常消息通信顺序进行不当，则会产生死锁</li></ul><p><strong>（2）进程间推进顺序非法</strong></p><p>系统中的资源可以分为两类：</p><ul><li>可剥夺资源，是指某进程在获得这类资源后，该资源可以再被其他进程或系统剥夺，CPU和主存均属于可剥夺性资源；</li><li>不可剥夺资源，当系统把这类资源分配给某进程后，再不能强行收回，只能在进程用完后自行释放，如磁带机、打印机等。</li></ul><p><strong>产生死锁的必要条件：</strong></p><p>互斥条件：进程要求对所分配的资源进行排它性控制，即在一段时间内某资源仅为一进程所占用。</p><p>请求和保持条件：当进程因请求资源而阻塞时，对已获得的资源保持不放。</p><p>不剥夺条件：进程已获得的资源在未使用完之前，不能剥夺，只能在使用完时由自己释放。</p><p>环路等待条件：在发生死锁时，必然存在一个进程——资源的环形链。</p><p><strong>预防死锁的方法：</strong></p><ul><li>资源一次性分配：一次性分配所有资源，这样就不会再有请求了（破坏请求条件）</li><li>只要有一个资源得不到分配，也不给这个进程分配其他的资源（破坏请保持条件）</li><li>可剥夺资源：即当某进程获得了部分资源，但得不到其它资源，则释放已占有的资源（破坏不可剥夺条件）</li><li>资源有序分配法：系统给每类资源赋予一个编号，每一个进程按编号递增的顺序请求资源，释放则相反（破坏环路等待条件）</li></ul><h3 id="如何实现浏览器内多个标签页之间的通信"><a href="#如何实现浏览器内多个标签页之间的通信" class="headerlink" title="如何实现浏览器内多个标签页之间的通信?"></a>如何实现浏览器内多个标签页之间的通信?</h3><p>本质上都是通过中介者模式来实现的。</p><p><strong>使用 websocket 协议</strong></p><p> 标签页通过向服务器发送数据，然后由服务器向其他标签页推送转发。</p><p><strong>使用 ShareWorker 的方式</strong></p><p>标签页间通过共享一个线程，然后通过这个共享的线程来实现数据的交换。</p><p><strong>使用 localStorage 的方式</strong></p><p>我们可以在一个标签页对 localStorage 的变化事件进行监听，然后当另一个标签页修改数据的时候，我们就可以通过这个监听事件来获取到数据。</p><p><strong>使用 postMessage 方法</strong></p><p>如果我们能够获得对应标签页的引用，就可以使用postMessage 方法，进行通信。</p><p>PostMessage 是 html5 新引进的一个可跨源通信 api，你可以通过这个 api，让主页面和任意 frame 类页面或 window.open 打开的页面进行双向通信。</p><h3 id="对Service-Worker的理解"><a href="#对Service-Worker的理解" class="headerlink" title="对Service Worker的理解"></a>对Service Worker的理解</h3><p>Service Worker 是运行在浏览器背后的<strong>独立线程</strong>，一般可以用来实现缓存功能。使用 Service Worker的话，传输协议必须为 <strong>HTTPS</strong>。因为 Service Worker 中涉及到请求拦截，所以必须使用 HTTPS 协议来保障安全。</p><h3 id="对浏览器的缓存机制的理解"><a href="#对浏览器的缓存机制的理解" class="headerlink" title="对浏览器的缓存机制的理解"></a>对浏览器的缓存机制的理解</h3><p>浏览器第一次加载资源，服务器返回 200</p><p>下一次加载资源时，由于强制缓存优先级较高，先比较当前时间与上一次返回 200 时的时间差，如果没有超过 cache-control 设置的 max-age，则没有过期，并命中强缓存，直接从本地读取资源。</p><p>如果资源已过期，则表明强制缓存没有被命中，则开始协商缓存，向服务器发送带有 If-None-Match 和 If-Modified-Since 的请求</p><p>服务器收到请求后，优先根据 Etag 的值判断被请求的文件有没有做修改，Etag 值一致则没有修改，命中协商缓存，返回 304；如果不一致则有改动，直接返回新的资源文件带上新的 Etag 值并返回 200；</p><p>如果服务器收到的请求没有 Etag 值，则将 If-Modified-Since 和被请求文件的最后修改时间做比对，一致则命中协商缓存，返回 304；不一致则返回新的 last-modified 和文件并返回 200；</p><h3 id="浏览器资源缓存的位置有哪些？"><a href="#浏览器资源缓存的位置有哪些？" class="headerlink" title="浏览器资源缓存的位置有哪些？"></a>浏览器资源缓存的位置有哪些？</h3><p><strong><strong>Service Worker：*<em>Service Worker 运行在 JavaScript 主线程之外，虽然由于脱离了浏览器窗体无法直接访问 DOM，但是它可以完成离线缓存、消息推送、网络代理等功能。*</em></strong></strong></p><p><strong>Memory Cache：</strong> Memory Cache 就是内存缓存，<strong>它的效率最快</strong></p><p><strong>Disk Cache：</strong> Push Cache 是 HTTP/2 中的内容，当以上三种缓存都没有命中时，它才会被使用。并且缓存时间也很短暂，只在会话（Session）中存在，一旦会话结束就被释放。</p><h3 id="协商缓存和强缓存的区别"><a href="#协商缓存和强缓存的区别" class="headerlink" title="协商缓存和强缓存的区别"></a>协商缓存和强缓存的区别</h3><p>（1）服务器通过在响应头中添加 Expires 属性，来指定资源的过期时间。</p><p>   (2)  Expires 是 http1.0 中的方式，因为它的一些缺点，在 HTTP 1.1 中提出了一个新的头部属性就是 Cache-Control 属性，它提供了对资源的缓存的更精确的控制。</p><p>(3) 使用强缓存策略时，如果缓存资源有效，则直接使用缓存资源，不必再向服务器发起请求。</p><p>命中协商缓存的条件有两个：</p><ul><li><code>max-age=xxx</code> 过期了</li><li>值为<code>no-store</code></li></ul><p>（1）服务器通过在响应头中添加 Last-Modified 属性来指出资源最后一次修改的时间，当浏览器下一次发起请求时，会在请求头中添加一个 If-Modified-Since 的属性，属性值为上一次资源返回时的 Last-Modified 的值。</p><p>（2）因为 Last-Modified 的这种可能发生的不准确性，http 中提供了另外一种方式，那就是 Etag 属性。</p><h3 id="为什么需要浏览器缓存？"><a href="#为什么需要浏览器缓存？" class="headerlink" title="为什么需要浏览器缓存？"></a>为什么需要浏览器缓存？</h3><p>在发起请求之后，拉取相应的静态资源，并保存在本地。如果服务器的静态资源没有更新，那么在下次请求的时候，就直接从本地读取即可，如果服务器的静态资源已经更新，那么我们再次请求的时候，就到服务器拉取新的资源，并保存在本地。<strong>这样就大大的减少了请求的次数，提高了网站的性能。</strong></p><p>使用浏览器缓存，有以下优点：</p><ul><li>减少了服务器的负担，提高了网站的性能</li><li>加快了客户端网页的加载速度</li><li>减少了多余网络数据传输</li></ul><h3 id="浏览器的渲染过程"><a href="#浏览器的渲染过程" class="headerlink" title="浏览器的渲染过程"></a>浏览器的渲染过程</h3><ul><li>首先解析收到的文档，根据文档定义构建一棵 DOM 树，DOM 树是由 DOM 元素及属性节点组成的。</li><li>然后对 CSS 进行解析，生成 CSSOM 规则树。</li><li>根据 DOM 树和 CSSOM 规则树构建渲染树。渲染树的节点被称为渲染对象，渲染对象是一个包含有颜色和大小等属性的矩形，渲染对象和 DOM 元素相对应，但这种对应关系不是一对一的，不可见的 DOM 元素不会被插入渲染树。还有一些 DOM元素对应几个可见对象，它们一般是一些具有复杂结构的元素，无法用一个矩形来描述。</li><li>当渲染对象被创建并添加到树中，它们并没有位置和大小，所以当浏览器生成渲染树以后，就会根据渲染树来进行布局（也可以叫做回流）。这一阶段浏览器要做的事情是要弄清楚各个节点在页面中的确切位置和大小。通常这一行为也被称为“自动重排”。</li><li>布局阶段结束后是绘制阶段，遍历渲染树并调用渲染对象的 paint 方法将它们的内容显示在屏幕上，绘制使用 UI 基础组件。</li></ul><h3 id="浏览器渲染优化"><a href="#浏览器渲染优化" class="headerlink" title="浏览器渲染优化"></a>浏览器渲染优化</h3><p><strong>针对JavaScript</strong></p><p>尽量将JavaScript文件放在body的最后</p><p>body中间尽量不要写<code>&lt;script&gt;</code>标签</p><script>标签的引入资源方式有三种，有一种就是我们常用的直接引入，还有两种就是使用 async 属性和 defer 属性来异步引入，两者都是去异步加载外部的JS文件，不会阻塞DOM的解析**针对CSS**- **link**：浏览器会派发一个新等线程(HTTP线程)去加载资源文件，与此同时GUI渲染线程会继续向下渲染代码- **@import**：GUI渲染线程会暂时停止渲染，去服务器加载资源文件，资源文件没有返回之前不会继续渲染(阻碍浏览器渲染)- **style**：GUI直接渲染在开发过程中，导入外部样式使用link，而不用@import。如果css少，尽可能采用内嵌样式，直接写在style标签中。- 使用语义化的标签，来避免不标准语义化的特殊处理**减少回流与重绘：**- 不要使用`table`布局， 一个小的改动可能会使整个`table`进行重新布局- 不要频繁操作元素的样式，对于静态页面，可以修改类名，而不是样式。，可以创建一个文档片段`documentFragment`，在它上面应用所有DOM操作，最后再把它添加到文档中- 将元素先设置`display: none`，操作结束后再把它显示出来。因为在display属性为none的元素上进行的DOM操作不会引发回流和重绘。- 将DOM的多个读操作（或者写操作）放在一起，而不是读写操作穿插着写。这得益于**浏览器的渲染队列机制**。**当队列中的操作到了一定的数量或者到了一定的时间间隔，浏览器就会对队列进行批处理。这样就会让多次的回流、重绘变成一次回流重绘。**### 浏览器本地存储方式及使用场景#### （1）Cookie如果需要域名之间跨域共享Cookie，有两种方法：1. 使用Nginx反向代理2. 在一个站点登陆之后，往其他网站写Cookie。服务端的Session存储到一个节点，Cookie存储sessionId**Cookie的使用场景：**- 最常见的使用场景就是Cookie和session结合使用，我们将sessionId存储到Cookie中，每次发请求都会携带这个sessionId，这样服务端就知道是谁发起的请求，从而响应相应的信息。- 可以用来统计页面的点击次数**LocalStorage的使用场景：**- 有些网站有换肤的功能，这时候就可以将换肤的信息存储在本地的LocalStorage中，当需要换肤的时候，直接操作LocalStorage即可- 在网站中的用户浏览信息也会存储在LocalStorage中，还有网站的一些不常变动的个人信息等也可以存储在本地的LocalStorage中**SessionStorage的使用场景**- 由于SessionStorage具有时效性，所以可以用来存储一些网站的游客登录的信息，还有临时的浏览记录的信息。当关闭网站之后，这些信息也就随之消除了。### Cookie有哪些字段，作用分别是什么服务器端可以使用 Set-Cookie 的响应头部来配置 cookie 信息。一条cookie 包括了5个属性值 expires、domain、path、secure、HttpOnly。其中 expires 指定了 cookie 失效的时间，domain 是域名、path是路径，domain 和 path 一起限制了 cookie 能够被哪些 url 访问。secure 规定了 cookie 只能在确保安全的情况下传输，HttpOnly 规定了这个 cookie 只能被服务器访问，不能使用 js 脚本访问。### Cookie、LocalStorage、SessionStorage区别**cookie：** 其实最开始是服务器端用于记录用户状态的一种方式，由服务器设置，在客户端存储，然后每次发起同源请求时，发送给服务器端。cookie 最多能存储 4 k 数据，它的生存时间由 expires 属性指定，并且 cookie 只能被同源的页面访问共享。**sessionStorage：** html5 提供的一种浏览器本地存储的方法，它借鉴了服务器端 session 的概念，代表的是一次会话中所保存的数据。它一般能够存储 5M 或者更大的数据，它在当前窗口关闭后就失效了，并且 sessionStorage 只能被同一个窗口的同源页面所访问共享。**localStorage：** html5 提供的一种浏览器本地存储的方法，它一般也能够存储 5M 或者更大的数据。它和 sessionStorage 不同的是，除非手动删除它，否则它不会失效，并且 localStorage 也只能被同源页面所访问共享。**同源政策主要限制了三个方面：**- 当前域下的 js 脚本不能够访问其他域下的 cookie、localStorage 和 indexDB。- 当前域下的 js 脚本不能够操作访问操作其他域下的 DOM。- 当前域下 ajax 无法发送跨域请求。###  如何解决跨越问题#### （1）CORS下面是MDN对于CORS的定义：> 跨域资源共享(CORS) 是一种机制，它使用额外的 HTTP 头来告诉浏览器  让运行在一个 origin (domain)上的Web应用被准许访问来自不同源服务器上的指定的资源。当一个资源从与该资源本身所在的服务器不同的域、协议或端口请求一个资源时，资源会发起一个跨域HTTP 请求。#### JSONP**jsonp**的原理就是利用`<script>`标签没有跨域限制，通过`<script>`标签src属性，发送带有callback参数的GET请求，服务端将接口返回数据拼凑到callback函数中，返回给浏览器，浏览器解析执行，从而前端拿到callback函数返回的数据。<script>    var script = document.createElement('script');    script.type = 'text/javascript';    // 传参一个回调函数名给后端，方便后端返回时执行这个在前端定义的回调函数    script.src = 'http://www.domain2.com:8080/login?user=admin&callback=handleCallback';    document.head.appendChild(script);    // 回调执行函数    function handleCallback(res) {        alert(JSON.stringify(res));    } </script><p><strong>JSONP的缺点：</strong></p><ul><li>具有局限性， 仅支持get方法</li><li>不安全，可能会遭受XSS攻击</li></ul><h4 id="（3）postMessage-跨域"><a href="#（3）postMessage-跨域" class="headerlink" title="（3）postMessage 跨域"></a>（3）postMessage 跨域</h4><p>postMessage是HTML5 XMLHttpRequest Level 2中的API，且是为数不多可以跨域操作的window属性之一，它可用于解决以下方面的问题：</p><ul><li>页面和其打开的新窗口的数据传递</li><li>多窗口之间消息传递</li><li>页面与嵌套的iframe消息传递</li><li>上面三个场景的跨域数据传递</li></ul><p>postMessage(data,origin)</p><h4 id="（4）nginx代理跨域"><a href="#（4）nginx代理跨域" class="headerlink" title="（4）nginx代理跨域"></a>（4）nginx代理跨域</h4><p>nginx代理跨域，实质和CORS跨域原理一样，通过配置文件设置请求响应头Access-Control-Allow-Origin…等字段。</p><h4 id="（5）nodejs-中间件代理跨域"><a href="#（5）nodejs-中间件代理跨域" class="headerlink" title="（5）nodejs 中间件代理跨域"></a>（5）nodejs 中间件代理跨域</h4><p>node中间件实现跨域代理，原理大致与nginx相同，都是通过启一个代理服务器，实现数据的转发，也可以通过设置cookieDomainRewrite参数修改响应头中cookie中域名，实现当前域的cookie写入，方便接口登录认证。</p><p>var express = require(‘express’);<br>var proxy = require(‘http-proxy-middleware’);<br>var app = express();<br>app.use(‘/‘, proxy({<br>    // 代理跨域目标接口<br>    target: ‘<a href="http://www.domain2.com:8080&#39;">http://www.domain2.com:8080&#39;</a>,<br>    changeOrigin: true,<br>    // 修改响应头信息，实现跨域并允许带cookie<br>    onProxyRes: function(proxyRes, req, res) {<br>        res.header(‘Access-Control-Allow-Origin’, ‘<a href="http://www.domain1.com&/#39;">http://www.domain1.com&#39;</a>);<br>        res.header(‘Access-Control-Allow-Credentials’, ‘true’);<br>    },<br>    // 修改响应信息中的cookie域名<br>    cookieDomainRewrite: ‘<a href="http://www.domain1.com&/#39;">www.domain1.com&#39;</a>  // 可以为false，表示不修改<br>}));<br>app.listen(3000);<br>console.log(‘Proxy server is listen at port 3000…’);</p><h4 id="（6）document-domain-iframe跨域"><a href="#（6）document-domain-iframe跨域" class="headerlink" title="（6）document.domain + iframe跨域"></a>（6）document.domain + iframe跨域</h4><h4 id="（7）location-hash-iframe跨域"><a href="#（7）location-hash-iframe跨域" class="headerlink" title="（7）location.hash + iframe跨域"></a>（7）location.hash + iframe跨域</h4><h4 id="（8）window-name-iframe跨域"><a href="#（8）window-name-iframe跨域" class="headerlink" title="（8）window.name + iframe跨域"></a>（8）window.name + iframe跨域</h4><h4 id="（9）WebSocket协议跨域"><a href="#（9）WebSocket协议跨域" class="headerlink" title="（9）WebSocket协议跨域"></a>（9）WebSocket协议跨域</h4><h3 id="正向代理和反向代理的区别"><a href="#正向代理和反向代理的区别" class="headerlink" title="正向代理和反向代理的区别"></a>正向代理和反向代理的区别</h3><ul><li><strong>正向代理：</strong></li></ul><p>客户端想获得一个服务器的数据，但是因为种种原因无法直接获取。于是客户端设置了一个代理服务器，并且指定目标服务器，之后代理服务器向目标服务器转交请求并将获得的内容发送给客户端。这样本质上起到了对真实服务器隐藏真实客户端的目的。实现正向代理需要修改客户端，比如修改浏览器配置。</p><ul><li><strong>反向代理：</strong></li></ul><p>服务器为了能够将工作负载分不到多个服务器来提高网站性能 (负载均衡)等目的，当其受到请求后，会首先根据转发规则来确定请求应该被转发到哪个服务器上，然后将请求转发到对应的真实服务器上。这样本质上起到了对客户端隐藏真实服务器的作用。 一般使用反向代理后，需要通过修改 DNS 让域名解析到代理服务器 IP，这时浏览器无法察觉到真正服务器的存在，当然也就不需要修改配置了。</p><p> client-proxy-server 的结构，它们主要的区别就在于中间这个 proxy 是哪一方设置的。在正向代理中，proxy 是 client 设置的，用来隐藏 client；而在反向代理中，proxy 是 server 设置的，用来隐藏 server。</p><h3 id="事件是什么？事件模型？"><a href="#事件是什么？事件模型？" class="headerlink" title="事件是什么？事件模型？"></a>事件是什么？事件模型？</h3><p>事件是用户操作网页时发生的交互动作，比如 click/move， 事件除了用户触发的动作外，还可以是文档加载，窗口滚动和大小调整。</p><p><strong>DOM0 级事件模型</strong>，这种模型不会传播，所以没有事件流的概念</p><p><strong>IE 事件模型</strong>，在该事件模型中，一次事件共有两个过程，事件处理阶段和事件冒泡阶段</p><p><strong>DOM2 级事件模型</strong>，在该事件模型中，一次事件共有三个过程，第一个过程是事件捕获阶段。捕获指的是事件从 document 一直向下传播到目标元素，依次检查经过的节点是否绑定了事件监听函数，如果有则执行。后面两个阶段和 IE 事件模型的两个阶段相同。这种事件模型，事件绑定的函数是addEventListener，其中第三个参数可以指定事件是否在捕获阶段执行。</p><h3 id="如何阻止事件冒泡"><a href="#如何阻止事件冒泡" class="headerlink" title="如何阻止事件冒泡"></a>如何阻止事件冒泡</h3><ul><li>普通浏览器使用：event.stopPropagation()</li><li>IE浏览器使用：event.cancelBubble = true;</li></ul><h3 id="对事件委托的理解"><a href="#对事件委托的理解" class="headerlink" title="对事件委托的理解"></a>对事件委托的理解</h3><h4 id="（1）事件委托的概念"><a href="#（1）事件委托的概念" class="headerlink" title="（1）事件委托的概念"></a>（1）事件委托的概念</h4><p>利用了<strong>浏览器事件冒泡</strong>的机制。因为事件在冒泡过程中会上传到父节点，父节点可以通过事件对象获取到目标节点，因此可以把子节点的监听函数定义在父节点上，由父节点的监听函数统一处理多个子元素的事件，这种方式称为事件委托（事件代理）。</p><h4 id="（2）事件委托的特点"><a href="#（2）事件委托的特点" class="headerlink" title="（2）事件委托的特点"></a>（2）事件委托的特点</h4><ul><li><p><strong>减少内存消耗</strong></p></li><li><p><strong>动态绑定事件</strong></p></li></ul><h4 id="（3）局限性"><a href="#（3）局限性" class="headerlink" title="（3）局限性"></a>（3）局限性</h4><p>事件委托会影响页面性能，主要影响因素有：</p><ul><li>元素中，绑定事件委托的次数；</li><li>点击的最底层元素，到绑定事件元素之间的<code>DOM</code>层数；</li></ul><h3 id="同步和异步的区别"><a href="#同步和异步的区别" class="headerlink" title="同步和异步的区别"></a>同步和异步的区别</h3><ul><li><strong>同步</strong>指的是当一个进程在执行某个请求时，如果这个请求需要等待一段时间才能返回，那么这个进程会一直等待下去，直到消息返回为止再继续向下执行。</li><li><strong>异步</strong>指的是当一个进程在执行某个请求时，如果这个请求需要等待一段时间才能返回，这个时候进程会继续往下执行，不会阻塞等待消息的返回，当消息返回时系统再通知进程进行处理。</li></ul><h3 id="对事件循环的理解"><a href="#对事件循环的理解" class="headerlink" title="对事件循环的理解"></a>对事件循环的理解</h3><p>Event Loop 执行顺序如下所示：</p><ul><li>首先执行同步代码，这属于宏任务</li><li>当执行完所有同步代码后，执行栈为空，查询是否有异步代码需要执行</li><li>执行所有微任务</li><li>当执行完所有微任务后，如有必要会渲染页面</li><li>然后开始下一轮 Event Loop，执行宏任务中的异步代码</li></ul><p>因为 js 是单线程运行的，在代码执行时，通过将不同函数的执行上下文压入执行栈中来保证代码的有序执行。在执行同步代码时，如果遇到异步事件，js 引擎并不会一直等待其返回结果，而是会将这个事件挂起，继续执行执行栈中的其他任务。当异步事件执行完毕后，再将异步事件对应的回调加入到一个任务队列中等待执行。任务队列可以分为宏任务队列和微任务队列，当当前执行栈中的事件执行完毕后，js 引擎首先会判断微任务队列中是否有任务可以执行，如果有就将微任务队首的事件压入栈中执行。当微任务队列中的任务都执行完成后再去执行宏任务队列中的任务。</p><h3 id="宏任务和微任务分别有哪些"><a href="#宏任务和微任务分别有哪些" class="headerlink" title="宏任务和微任务分别有哪些"></a>宏任务和微任务分别有哪些</h3><ul><li>微任务包括： promise 的回调、node 中的 process.nextTick 、对 Dom 变化监听的 MutationObserver。</li><li>宏任务包括： script 脚本的执行、setTimeout ，setInterval ，setImmediate 一类的定时事件，还有如 I/O 操作、UI 渲染等。</li></ul><p>可以把执行栈认为是一个存储函数调用的<strong>栈结构</strong>，遵循先进后出的原则。</p><h3 id="Node-中的-Event-Loop-和浏览器中的有什么区别？process-nextTick-执行顺序？"><a href="#Node-中的-Event-Loop-和浏览器中的有什么区别？process-nextTick-执行顺序？" class="headerlink" title="Node 中的 Event Loop 和浏览器中的有什么区别？process.nextTick 执行顺序？"></a>Node 中的 Event Loop 和浏览器中的有什么区别？process.nextTick 执行顺序？</h3><p>Node 的 Event Loop 分为 6 个阶段，它们会按照<strong>顺序</strong>反复运行。每当进入某一个阶段的时候，都会从对应的回调队列中取出函数去执行。当队列为空或者执行的回调函数数量到达系统设定的阈值，就会进入下一阶段。</p><p>（1）<strong>Timers（计时器阶段）</strong></p><p>此阶段会判断是否存在过期的计时器回调（包含 setTimeout 和 setInterval），如果存在则会执行所有过期的计时器回调，执行完毕后，如果回调中触发了相应的微任务，会接着执行所有微任务，执行完微任务后再进入 Pending callbacks 阶段。</p><p><strong>/Prepare</strong>：仅供内部使用。</p><p><strong>Poll（轮询阶段）</strong>：</p><p><strong>Check（查询阶段）</strong>：会检查是否存在 setImmediate 相关的回调，如果存在则执行所有回调，执行完毕后，如果回调中触发了相应的微任务，会接着执行所有微任务，执行完微任务后再进入 Close callbacks 阶段。</p><p><strong>Close callbacks</strong>：执行一些关闭回调，比如socket.on(‘close’, …)等。</p><h3 id="哪些操作会造成内存泄漏？"><a href="#哪些操作会造成内存泄漏？" class="headerlink" title="哪些操作会造成内存泄漏？"></a>哪些操作会造成内存泄漏？</h3><p>第一种情况是由于使用未声明的变量，而意外的创建了一个全局变量，而使这个变量一直留在内存中无法被回收。</p><p>第二种情况是设置了 setInterval 定时器，而忘记取消它，如果循环函数有对外部变量的引用的话，那么这个变量会被一直留在内存中，而无法被回收。</p><p>第三种情况是获取一个 DOM 元素的引用，而后面这个元素被删除，由于我们一直保留了对这个元素的引用，所以它也无法被回收。</p><p>第四种情况是不合理的使用闭包，从而导致某些变量一直被留在内存当中。</p>]]></content>
      
      
      <categories>
          
          <category> 浏览器 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> web前端 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计算机网络</title>
      <link href="/2022/11/22/%E7%AC%AC%E4%BA%94%E7%AF%87%E6%96%87%E7%AB%A0/"/>
      <url>/2022/11/22/%E7%AC%AC%E4%BA%94%E7%AF%87%E6%96%87%E7%AB%A0/</url>
      
        <content type="html"><![CDATA[<h3 id="传输层"><a href="#传输层" class="headerlink" title="传输层"></a>传输层</h3><p>主要功能：</p><p>1.提供进程和进程之间的逻辑通信</p><p>2.复用和分用</p><p><strong>复用</strong>：应用层所有的应用进程都可以通过传输层再传输到网络层</p><p><strong>分用</strong>：传输层从网络层收到数据后交付指明的应用进程</p><p>3.对收到的报文进行差错检测</p><p><strong>套接字</strong>   = （主机IP地址，端口号）</p><h3 id="UDP协议的特点："><a href="#UDP协议的特点：" class="headerlink" title="UDP协议的特点："></a>UDP协议的特点：</h3><p>1.无连接， 减少时延</p><p>2.不保证可靠交付 （由应用层保证可靠交付）</p><p>3.面向报文，适合一次性传输少量数据的网络应用</p><p>4.无拥塞控制，适合实时应用</p><p>5.首部开销小，8B</p><h3 id="TCP协议的特点："><a href="#TCP协议的特点：" class="headerlink" title="TCP协议的特点："></a>TCP协议的特点：</h3><p>1.面向连接(打call)</p><p>2.可靠有序，不丢不重</p><p>3.全双工通信  （收发缓存）</p><p>4.面向字节流</p><h4 id="TCP连接管理"><a href="#TCP连接管理" class="headerlink" title="TCP连接管理"></a>TCP连接管理</h4><p>建立连接=》 数据传送 =》 连接释放</p><p><strong>三次握手阶段：</strong></p><p>1.客户端发送连接请求报文段： </p><p>SYN = 1， seq = x</p><p>2.服务器端为该TCP连接分配缓存和变量，并向客户端返回确认报文段，允许连接。</p><p>sYN= 1,ACK=1, seq = y ，ack = x+1</p><p>3.分配缓存和变量，并向服务器端返回确认的确认，可以携带数据</p><p>syn = 0， ack =1 ，seq= x+1， ack = y+1</p><p><strong>四次挥手：</strong></p><p>1.客户端发送连接释放报文端，</p><p>2.服务器回送一个确认报文段，</p><p>3.服务器端发送完成，就发出连接释放报文段，主动关闭tcp连接</p><p>4.客户端回送一个确认报文段，等到彻底关闭。</p><h3 id="tcp可靠传输，可靠是什么？"><a href="#tcp可靠传输，可靠是什么？" class="headerlink" title="tcp可靠传输，可靠是什么？"></a>tcp可靠传输，可靠是什么？</h3><p>保证接收方进程从缓存区读出的字节流和发送方发出的字节流是完全一样的</p><p>机制：</p><p>1.校验  （增加伪首部）</p><p>2.序号    </p><p>3.确认</p><p>4.重传</p><p>超时重传：tcp的发送方在规定时间内没有收到确认就要重传已发送的报文段</p><p>tcp采用自适应算法，动态改变重传时间Rtts（加权平均往返时间）</p><p>冗余ack：每当比期望序号大的失序报文段到达时，发送一个冗余ACK，指明下一个期待字节的序号。</p><h3 id="TCP流量控制"><a href="#TCP流量控制" class="headerlink" title="TCP流量控制"></a>TCP流量控制</h3><p>利用滑动窗口机制实现流量控制</p><h3 id="TCP拥塞控制"><a href="#TCP拥塞控制" class="headerlink" title="TCP拥塞控制"></a>TCP拥塞控制</h3><p>出现拥塞的条件：</p><p>​       对资源需求的总和&gt;可用资源</p><p>网络中有许多资源同时呈现供应不足=》网络性能变坏=》网络吞吐量将随输入负荷增大而下降</p><h3 id="GET和POST的请求的区别"><a href="#GET和POST的请求的区别" class="headerlink" title="GET和POST的请求的区别"></a>GET和POST的请求的区别</h3><p><strong>应用场景</strong> </p><p><strong>是否缓存</strong></p><p><strong>发送的报文格式</strong></p><p><strong>安全性</strong></p><p><strong>请求长度</strong></p><h3 id="常见的HTTP请求头和响应头"><a href="#常见的HTTP请求头和响应头" class="headerlink" title="常见的HTTP请求头和响应头"></a>常见的HTTP请求头和响应头</h3><p><strong>HTTP Request Header 常见的请求头：</strong></p><ul><li><p>Referer：发出请求的页面的URL</p></li><li><p>User-Agent：浏览器的用户代理字符串</p></li><li><p>Connection：浏览器与服务器之间连接的类型</p></li><li><p>Host：发出请求的页面所在的域</p></li></ul><p><strong>HTTP Responses Header 常见的响应头：</strong></p><ul><li><p>server:服务器名称</p></li><li><p>Cache-Control：控制HTTP缓存</p></li><li><p>content-type:表示后面的文档属于什么MIME类型</p></li></ul><p>application/x-www-form-urlencoded：浏览器的原生 form 表单</p><p>application/json：服务器消息主体是序列化后的 JSON 字符串。</p><p>text/xml：该种方式主要用来提交 XML 格式的数据</p><h3 id="常见的HTTP请求方法"><a href="#常见的HTTP请求方法" class="headerlink" title="常见的HTTP请求方法"></a>常见的HTTP请求方法</h3><p>GET: 向服务器获取数据；</p><p>POST：将实体提交到指定的资源，通常会造成服务器资源的修改；</p><p>PUT：上传文件，更新数据；</p><p>DELETE：删除服务器上的对象；</p><p>HEAD：获取报文首部，与GET相比，不返回报文主体部分；</p><p>OPTIONS：询问支持的请求方法，用来跨域请求；</p><h3 id="OPTIONS请求方法及使用场景"><a href="#OPTIONS请求方法及使用场景" class="headerlink" title="OPTIONS请求方法及使用场景"></a>OPTIONS请求方法及使用场景</h3><p>OPTIONS方法是用于请求获得由<code>Request-URI</code>标识的资源在请求/响应的通信过程中可以使用的功能选项。通过这个方法，客户端可以<strong>在采取具体资源请求之前，决定对该资源采取何种必要措施，或者了解服务器的性能</strong>。该请求方法的响应不能缓存。</p><ul><li>获取服务器支持的所有HTTP请求方法；</li><li>用来检查访问权限。例如：在进行 CORS 跨域资源共享时，对于复杂请求，就是使用 OPTIONS 方法发送嗅探请求，以判断是否有对指定资源的访问权限。</li></ul><h3 id="HTTP-1-0-和-HTTP-1-1-之间有哪些区别？"><a href="#HTTP-1-0-和-HTTP-1-1-之间有哪些区别？" class="headerlink" title="HTTP 1.0 和 HTTP 1.1 之间有哪些区别？"></a>HTTP 1.0 和 HTTP 1.1 之间有哪些区别？</h3><p><strong>连接方面</strong> http1.1 通过使用持久连接来使多个 http 请求复用同一个 TCP 连接，以此来避免使用非持久连接时每次需要建立连接的时延。</p><p><strong>资源请求方面</strong> </p><p>在 http1.0 中，存在一些浪费带宽的现象，并且不支持断点续传功能</p><p> http1.1 则在请求头引入了 range 头域，它允许只请求资源的某个部分，即返回码是 206</p><p><strong>缓存方面</strong></p><p>在 http1.0 中主要使用 header 里的 If-Modified-Since、Expires 来做为缓存判断的标准</p><p>http1.1 则引入了更多的缓存控制策略，例如 Etag、If-Unmodified-Since、If-Match、If-None-Match 等更多可供选择的缓存头来控制缓存策略。</p><p><strong>http1.1 中新增了 host 字段</strong></p><p>用来指定服务器的域名</p><p><strong>http1.1 相对于 http1.0 还新增了很多请求方法</strong>，如 PUT、HEAD、OPTIONS 等</p><h3 id="HTTP-1-1-和-HTTP-2-0-的区别"><a href="#HTTP-1-1-和-HTTP-2-0-的区别" class="headerlink" title="HTTP 1.1 和 HTTP 2.0 的区别"></a>HTTP 1.1 和 HTTP 2.0 的区别</h3><p><strong>二进制协议</strong></p><p>在 HTTP/1.1 版中，报文的头信息必须是文本（ASCII 编码），数据体可以是文本，也可以是二进制。HTTP/2 则是一个彻底的二进制协议，头信息和数据体都是二进制，并且统称为”帧”，可以分为头信息帧和数据帧。 帧的概念是它实现多路复用的基础。</p><p><strong>多路复用</strong></p><p>HTTP/2 仍然复用 TCP 连接，但是在一个连接里，客户端和服务器都可以同时发送多个请求或回应，而且不用按照顺序一一发送，这样就避免了”队头堵塞”的问题。</p><p>在<code>HTTP 1</code>下，浏览器对一个域名下最大TCP连接数为6，所以会请求多次</p><p>在<code>HTTP 2</code>下，可以一瞬间加载出来很多资源，因为，HTTP2支持多路复用</p><p><strong>头信息压缩</strong></p><p>HTTP/2 实现了头信息压缩，由于 HTTP 1.1 协议不带状态，每次请求都必须附上所有信息。</p><p>一方面，头信息使用 gzip 或 compress 压缩后再发送；另一方面，客户端和服务器同时维护一张头信息表，所有字段都会存入这个表，生成一个索引号，以后就不发送同样字段了，只发送索引号，这样就能提高速度了。</p><p><strong>服务器推送</strong></p><p>HTTP/2 允许服务器未经请求，主动向客户端发送资源</p><p>这里需要注意的是 http2 下服务器主动推送的是静态资源，和 WebSocket 以及使用 SSE 等方式向客户端发送即时数据的推送是不同的。</p><h3 id="HTTP和HTTPS协议的区别"><a href="#HTTP和HTTPS协议的区别" class="headerlink" title="HTTP和HTTPS协议的区别"></a>HTTP和HTTPS协议的区别</h3><ul><li><p>HTTPS协议需要CA证书，费用较高；而HTTP协议不需要；</p></li><li><p>HTTP协议是超文本传输协议，信息是明文传输的，HTTPS则是具有安全性的SSL加密传输协议</p></li><li><p>使用不同的连接方式，端口也不同，HTTP协议端口是80，HTTPS协议端口是443；</p></li></ul><h3 id="GET方法URL长度限制的原因"><a href="#GET方法URL长度限制的原因" class="headerlink" title="GET方法URL长度限制的原因"></a>GET方法URL长度限制的原因</h3><p>实际上HTTP协议规范并没有对get方法请求的url长度进行限制，这个限制是特定的浏览器及服务器对它的限制。 IE对URL长度的限制是2083字节(2K+35)。</p><h3 id="当在浏览器中输入-Google-com-并且按下回车之后发生了什么？"><a href="#当在浏览器中输入-Google-com-并且按下回车之后发生了什么？" class="headerlink" title="当在浏览器中输入 Google.com 并且按下回车之后发生了什么？"></a>当在浏览器中输入 Google.com 并且按下回车之后发生了什么？</h3><p><strong>解析URL：</strong></p><p><strong>缓存判断：</strong></p><p><strong>DNS解析</strong></p><p><strong>获取MAC地址</strong></p><p><strong>TCP三次握手</strong></p><p><strong>HTTPS握手</strong></p><p><strong>返回数据</strong></p><p><strong>页面渲染</strong></p><p><strong>TCP四次挥手</strong></p><h3 id="对keep-alive的理解"><a href="#对keep-alive的理解" class="headerlink" title="对keep-alive的理解"></a>对keep-alive的理解</h3><p>HTTP1.0版本是默认没有Keep-alive的，所以要想连接得到保持，必须手动配置发送<code>Connection: keep-alive</code>字段。若想断开keep-alive连接，需发送<code>Connection:close</code>字段；</p><p>HTTP1.1规定了默认保持长连接，数据传输完成了保持TCP连接不断开，等待在同域名下继续用这个通道传输数据。如果需要关闭，需要客户端发送<code>Connection：close</code>首部字段</p><p>开启Keep-Alive的<strong>优点：</strong></p><ul><li>降低拥塞控制 （TCP连接减少了）；</li><li>减少了后续请求的延迟（⽆需再进⾏握⼿）；</li></ul><p>开启Keep-Alive的<strong>缺点</strong>：</p><ul><li>长时间的Tcp连接容易导致系统资源无效占用，浪费系统资源。</li></ul><h3 id="HTTP2的头部压缩算法是怎样的？"><a href="#HTTP2的头部压缩算法是怎样的？" class="headerlink" title="HTTP2的头部压缩算法是怎样的？"></a>HTTP2的头部压缩算法是怎样的？</h3><p>HTTP2的头部压缩是HPACK算法。在客户端和服务器两端建立“字典”，用索引号表示重复的字符串，采用哈夫曼编码来压缩整数和字符串，可以达到50%~90%的高压缩率。</p><ul><li>在客户端和服务器端使用“首部表”来跟踪和存储之前发送的键值对，对于相同的数据，不再通过每次请求和响应发送；连接存续期内始终存在，由客户端和服务器共同渐进地更新</li></ul><h3 id="HTTP请求报文的是什么样的？"><a href="#HTTP请求报文的是什么样的？" class="headerlink" title="HTTP请求报文的是什么样的？"></a>HTTP请求报文的是什么样的？</h3><ul><li><p>请求⾏</p><p>请求⽅法字段、URL字段、HTTP协议版本字段。GET /index.html HTTP/1.1。</p></li><li><p>请求头部</p><p>由关键字/值对组成 User-Agent：产⽣请求的浏览器类型。</p></li><li><p>空⾏</p><p>它的作用是通过一个空行，告诉服务器请求头部到此为止。</p></li><li><p>请求体</p></li></ul><p>​         post put等请求携带的数据</p><h3 id="说一下HTTP-3-0"><a href="#说一下HTTP-3-0" class="headerlink" title="说一下HTTP 3.0"></a>说一下HTTP 3.0</h3><p>​    HTTP/3基于UDP协议实现了类似于TCP的多路复用数据流、传输可靠性等功能，这套功能被称为QUIC协议。</p><ol><li>流量控制、传输可靠性功能：QUIC在UDP的基础上增加了一层来保证数据传输可靠性，它提供了数据包重传、拥塞控制、以及其他一些TCP中的特性。</li><li>快速握手：由于基于UDP，可以实现使用0 ~ 1个RTT来建立连接</li><li>多路复用：同一物理连接上可以有多个独立的逻辑数据流，实现了数据流的单独传输，解决了TCP的队头阻塞问题。</li></ol><h3 id="与缓存相关的HTTP请求头有哪些"><a href="#与缓存相关的HTTP请求头有哪些" class="headerlink" title="与缓存相关的HTTP请求头有哪些"></a>与缓存相关的HTTP请求头有哪些</h3><p>强缓存：</p><ul><li>Expires</li><li>Cache-Control</li></ul><p>协商缓存：</p><ul><li>Etag、If-None-Match</li><li>Last-Modified、If-Modified-Since</li></ul><h4 id="HTTPS的主要目的是提供对网站服务器的身份认证，保护交换数据的隐私与完整性。"><a href="#HTTPS的主要目的是提供对网站服务器的身份认证，保护交换数据的隐私与完整性。" class="headerlink" title="HTTPS的主要目的是提供对网站服务器的身份认证，保护交换数据的隐私与完整性。"></a>HTTPS的主要目的是提供对网站服务器的身份认证，保护交换数据的隐私与完整性。</h4><h3 id="TLS-SSL的工作原理"><a href="#TLS-SSL的工作原理" class="headerlink" title="TLS/SSL的工作原理"></a>TLS/SSL的工作原理</h3><p><strong>TLS/SSL</strong>全称<strong>安全传输层协议</strong>（Transport Layer Security）, 是介于TCP和HTTP之间的一层安全协议，不影响原有的TCP协议和HTTP协议</p><p><strong>散列函数hash</strong>、<strong>对称加密</strong>、<strong>非对称加密</strong></p><ul><li><p>基于散列函数验证信息的完整性    MD5</p><p>在信息传输过程中，散列函数不能三都实现信息防篡改，由于传输是明文传输，中间人可以修改信息后重新计算信息的摘要，所以需要对传输的信息和信息摘要进行加密。</p></li><li><p>对称加密算法采用协商的秘钥对数据加密  AES-CBC   </p><p>对称加密的优势就是信息传输使用一对一，需要共享相同的密码，密码的安全是保证信息安全的基础，服务器和N个客户端通信，需要维持N个密码记录且不能修改密码。</p></li><li><p>非对称加密实现身份认证和秘钥协商  RSA</p></li></ul><p>​    我们拥有两个秘钥，一个是公钥，一个是私钥。 </p><p>​    非对称加密的特点就是信息一对多，服务器只需要维持一个私钥就可以和多个客户端进行通信，但服务器发出的信息能够被所有的客户端解密，且该算法的计算复杂，加密的速度慢。</p><h3 id="HTTPS通信（握手）过程"><a href="#HTTPS通信（握手）过程" class="headerlink" title="HTTPS通信（握手）过程"></a>HTTPS通信（握手）过程</h3><p>1.协议版本号 生成的一个随机数 以及客户端支持的加密方法。</p><p> 2.确认双方使用的加密方法、并给出服务器的证书、以及一个服务器生成的随机数。</p><p>3.确认服务器证书有效并生成随机数，使用公钥，加密随机数。</p><p>4.服务器使用自己的私钥，来解密客户端发送过来的随机数</p><p>5.密方法使用前面的三个随机数，生成对话秘钥，以后的对话过程都使用这个秘钥来加密信息。</p><h2 id="HTTP状态码"><a href="#HTTP状态码" class="headerlink" title="HTTP状态码"></a>HTTP状态码</h2><p><strong>1xx 接受的请求正在处理</strong></p><p>2xx 成功状态码 200 ok 204  该状态码表示客户端发送的请求已经在服务器端正常处理了，但是没有返回的内容，响应报文中不包含实体的主体部分</p><p><strong>3xx 重定向状态码</strong></p><p>301 <strong>永久重定向。</strong> 该状态码表示请求的资源已经被分配了新的 URI，以后应使用资源指定的 URI。</p><p>302 <strong>临时重定向。</strong> 该状态码表示请求的资源被分配到了新的 URI，希望用户（本次）能使用新的 URI 访问资源。</p><p>304 <strong>浏览器缓存相关</strong> 告诉客户端有缓存，直接使用缓存中的数据</p><p><strong>4xx客户端错误状态码</strong></p><p>400 bad request 该状态码表示请求报文中存在语法错误</p><p>401 unauthorized</p><p>403  Forbidden 该状态码表明请求资源的访问被服务器拒绝了</p><h4 id="404-Not-Found-该状态码表明服务器上无法找到请求的资源"><a href="#404-Not-Found-该状态码表明服务器上无法找到请求的资源" class="headerlink" title="404 Not Found   该状态码表明服务器上无法找到请求的资源"></a>404 Not Found   该状态码表明服务器上无法找到请求的资源</h4><p><strong>5xx服务器错误状态码</strong></p><h4 id="500-Internal-Server-Error"><a href="#500-Internal-Server-Error" class="headerlink" title="500 Internal Server Error"></a>500 Internal Server Error</h4><p>该状态码表明服务器端在执行请求时发生了错误。</p><h4 id="502-Bad-Gateway"><a href="#502-Bad-Gateway" class="headerlink" title="502 Bad Gateway"></a>502 Bad Gateway</h4><p>该状态码表明扮演网关或代理角色的服务器，从上游服务器中接收到的响应是无效的。</p><h3 id="DNS-协议是什么"><a href="#DNS-协议是什么" class="headerlink" title="DNS 协议是什么"></a>DNS 协议是什么</h3><p>提供的是一种主机名到 IP 地址的转换服务，就是我们常说的域名系统。</p><p><strong>DNS占用53号端口，同时使用TCP和UDP协议。</strong></p><h3 id="DNS完整的查询过程"><a href="#DNS完整的查询过程" class="headerlink" title="DNS完整的查询过程"></a>DNS完整的查询过程</h3><p><strong>浏览器的缓存</strong> =》<strong>本地DNS服务器</strong>=》<strong>根域名服务器</strong>=》<strong>顶级域名服务器</strong>=》<strong>权威域名服务器</strong>=》返回结果保存在缓存中</p><h3 id="迭代查询与递归查询"><a href="#迭代查询与递归查询" class="headerlink" title="迭代查询与递归查询"></a>迭代查询与递归查询</h3><p><strong>递归查询</strong>用户只需要发出一次查询请求    用户需要发出多次的查询请求</p><p><strong>迭代查询</strong>用户需要发出 多次的查询请求    本地 DNS 服务器向其他域名服务器请求的过程是迭代查询的过程，因为每一次域名服务器只返回单次 查询的结果，下一级的查询由本地 DNS 服务器自己进行。</p><h3 id="OSI七层模型通信特点："><a href="#OSI七层模型通信特点：" class="headerlink" title="OSI七层模型通信特点："></a><strong>OSI七层模型通信特点：</strong></h3><p><strong>对等通信</strong> 对等通信，为了使数据分组从源传送到目的地，源端OSI模型的每一层都必须与目的端的对等层进行通信，这种通信方式称为对等层通信</p><h3 id="三次握手"><a href="#三次握手" class="headerlink" title="三次握手"></a>三次握手</h3><p>TCP 三次握手的建立连接的过程就是相互确认初始序号的过程，告诉对方，什么样序号的报文段能够被正确接收。 第三次握手的作用是客户端对服务器端的初始序号的确认。如果只使用两次握手，那么服务器就没有办法知道自己的序号是否 已被确认。同时这样也是为了防止失效的请求报文段被服务器接收，而出现错误的情况。</p><h3 id="TCP粘包是怎么回事，如何处理"><a href="#TCP粘包是怎么回事，如何处理" class="headerlink" title="TCP粘包是怎么回事，如何处理?"></a>TCP粘包是怎么回事，如何处理?</h3><p>默认情况下, TCP 连接会启⽤延迟传送算法 (Nagle 算法), 在数据发送之前缓存他们. 如果短时间有多个数据发送, 会缓冲到⼀起作⼀次发送 (缓冲⼤⼩⻅ socket.bufferSize ), 这样可以减少 IO 消耗提⾼性能.</p><p><strong>多次发送之前间隔⼀个等待时间</strong></p><p><strong>关闭 Nagle 算法</strong></p><p><strong>进⾏封包/拆包</strong> 放⼀些有特征的数据, 然后收到数据的时 候根据特征数据分割出来各个数据包。 ⽬前业内常⻅的解决⽅案</p><h3 id="为什么udp不会粘包？"><a href="#为什么udp不会粘包？" class="headerlink" title="为什么udp不会粘包？"></a>为什么<strong>udp</strong>不会粘包？</h3><ul><li>UDP是⾯向消息的协议。UDP段都是⼀条消息，应⽤程序必须以消息为单位提取数据，不能⼀次提取任意字节的数据</li><li>UDP具有保护消息边界，在每个UDP包中就有了消息头，这样对于接收端来说就容易进⾏区分处理了</li></ul><h3 id="对-WebSocket-的理解"><a href="#对-WebSocket-的理解" class="headerlink" title="对 WebSocket 的理解"></a>对 WebSocket 的理解</h3><p>WebSocket是HTML5提供的一种浏览器与服务器进行<strong>全双工通讯</strong>的网络技术，属于应用层协议。它基于TCP传输协议，并复用HTTP的握手通道。浏览器和服务器只需要完成一次握手，两者之间就直接可以创建持久性的连接， 并进行双向数据传输。</p><p>WebSocket 的出现就解决了半双工通信的弊端。它最大的特点是：<strong>服务器可以向客户端主动推动消息，客户端也可以主动向服务器推送消息。</strong></p><p><strong>WebSocket原理</strong>：客户端向 WebSocket 服务器通知（notify）一个带有所有接收者ID（recipients IDs）的事件（event），服务器接收后立即通知所有活跃的（active）客户端，只有ID在接收者ID序列中的客户端才会处理这个事件。 </p><p>对于这四种即使通信协议，从性能的角度来看： <strong>WebSocket &gt; 长连接（SEE） &gt; 长轮询 &gt; 短轮询</strong> 但是，我们如果考虑浏览器的兼容性问题，顺序就恰恰相反了： <strong>短轮询 &gt; 长轮询 &gt; 长连接（SEE） &gt; WebSocket</strong> 所以，还是要根据具体的使用场景来判断使用哪种方式。</p><p><strong>短轮询的基本思路：</strong> 浏览器每隔一段时间向浏览器发送 http 请求，服务器端在收到请求后，不论是否有数据更新，都直接进行响应。</p><p><strong>轮询的基本思路：</strong> 首先由客户端向服务器发起请求，当服务器收到客户端发来的请求后，服务器端不会直接进行响应，而是先将这个请求挂起，然后判断服务器端数据是否有更新。</p><p><strong>SSE 的基本思想：</strong> 服务器使用流信息向服务器推送信息。严格地说，http 协议无法做到服务器主动推送信息。但是，有一种变通方法，就是服务器向客户端声明，接下来要发送的是流信息。也就是说，发送的不是一次性的数据包，而是一个数据流，会连续不断地发送过来。</p><p><strong>WebSocket</strong> 是 HTML5 定义的一个新协议议，与传统的 http 协议不同，该协议允许由服务器主动的向客户端推送信息。使用 WebSocket 协议的缺点是在服务器端的配置比较复杂。</p>]]></content>
      
      
      <categories>
          
          <category> 计算机 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> HTTP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Vue篇</title>
      <link href="/2022/11/21/%E7%AC%AC%E4%B8%83%E7%AF%87%E6%96%87%E7%AB%A0/"/>
      <url>/2022/11/21/%E7%AC%AC%E4%B8%83%E7%AF%87%E6%96%87%E7%AB%A0/</url>
      
        <content type="html"><![CDATA[<p>@[toc]</p><h2 id="vue响应式原理"><a href="#vue响应式原理" class="headerlink" title="vue响应式原理"></a>vue响应式原理</h2><p>数据响应式原理的核心就是采用了数据劫持结合发布者-订阅者模式的方式来实现数据的响应式,当你把一个普通的 JavaScript 对象传入 Vue 实例作为 data 选项，Vue 将遍历此对象所有的 property，并使用 Object.defineProperty 把这些 property 全部转为 getter/setter。get（）方法可以读取数据、收集依赖，set（）方法可以改写数据，在数据变动时会对数据进行比较，如果数据发生了变化，会发布消息通知订阅者，触发监听回调，更新视图。<br><strong>watcher</strong>： 每个组件实例都有相应的 watcher 程序实例，它会在组件渲染的过程中把属性记录为依赖，之后当依赖项的setter被调用时，会通知watcher重新计算，从而致使它关联的组件得以更新。</p><h2 id="defineProperty-的缺点"><a href="#defineProperty-的缺点" class="headerlink" title="defineProperty() 的缺点"></a>defineProperty() 的缺点</h2><ul><li>在对一些属性进行操作时，使用这种方法无法拦截，比如<strong>通过下标方式修改数组数据或者给对象新增属性</strong>，这都不能触发组件的重新渲染，因为 Object.defineProperty 不能拦截到这些操作。更精确的来说，对于数组而言，大部分操作都是拦截不到的，只是 Vue 内部通过重写函数的方式解决了这个问题。<h2 id="vue2-0如何监听数组或对象"><a href="#vue2-0如何监听数组或对象" class="headerlink" title="vue2.0如何监听数组或对象"></a>vue2.0如何监听数组或对象</h2>Vue 不允许动态添加根级响应式属性</li></ul><ol><li>官网给的建议是：使用vue.$Set(你要改变的数组/对象，你要改变的位置/key，你要改成什么value)或者vue.set</li><li>vue源码里缓存了array的原型链，然后重写了这几个方法，触发这几个方法的时候会observer数据，意思是使用这些方法不用再进行额外的操作，视图自动进行更新。splice()</li><li><img src="https://img-blog.csdnimg.cn/cc246b1eb9334142952a6993f9b2a62c.png" alt="在这里插入图片描述"></li></ol><blockquote><p>区别在于Vue.set()是将set函数绑定在Vue构造函数上，<code>this.$set()</code>是将set函数绑定在Vue原型上。 set和$set的区别</p></blockquote><h2 id="vue-set的实现原理"><a href="#vue-set的实现原理" class="headerlink" title="vue.$set的实现原理"></a>vue.$set的实现原理</h2><ul><li>如果目标是数组，直接使用数组的 splice 方法触发相应式；</li><li>如果目标是对象，会先判读属性是否存在、对象是否是响应式，最终如果要对属性进行响应式处理，则是通过调用 defineReactive 方法进行响应式处理（ defineReactive 方法就是 Vue 在初始化对象时，给对象属性采用 Object.defineProperty 动态添加 getter 和 setter 的功能所调用的方法）<h2 id="vue2-0为什么不劫持数组"><a href="#vue2-0为什么不劫持数组" class="headerlink" title="vue2.0为什么不劫持数组"></a>vue2.0为什么不劫持数组</h2></li></ul><p> 1.Obejct.definePropetry这个api，其实他是可以监听到数组下标变化的，对于js来说，数组也是Object。<br>    2.为什么vue不劫持数组:<br>因为数组不像对象那样，即使位置错乱，key和value对应关系一般不会变，每个value更新只会造成一次set。而数组则不一样，它只能通过下标去做key，这个key是不固定的，位置变化就会造成多次set操作，vue官方也考虑到性能问题，所以没有对数组做劫持，而是将数组的7个变异方法进行重写，也就是更改了Array原型上的方法达到劫持的效果。</p><h2 id="vue3-0是怎么做的劫持"><a href="#vue3-0是怎么做的劫持" class="headerlink" title="vue3.0是怎么做的劫持"></a>vue3.0是怎么做的劫持</h2><p> 1.通过使用 Proxy 对对象进行代理，从而实现数据劫持。使用Proxy 的好处是它可以完美的监听到任何方式的数据改变，唯一的缺点是兼容性的问题，因为 Proxy 是 ES6 的语法。<br> 2.Proxy只会代理对象的第一层，Vue3是怎样处理这个问题的呢？<br>判断当前Reflect.get的返回值是否为Object，如果是则再通过reactive方法做代理， 这样就实现了深度观测。<br>监测数组的时候可能触发多次get/set，那么如何防止触发多次呢？我们可以判断key是否为当前被代理对象target自身属性，也可以判断旧值与新值是否相等，只有满足以上两个条件之一时，才有可能执行trigger。</p><h2 id="为什么vue2-0不用proxy"><a href="#为什么vue2-0不用proxy" class="headerlink" title="为什么vue2.0不用proxy"></a>为什么vue2.0不用proxy</h2><p> vue2.x之前之所以不用Proxy,主要Proxy是es6提供的新特性,兼容性不好,最主要的是这个属性无法用polyfill来兼容。Polyfill 指的是用于实现浏览器并不支持的原生 API 的代码。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">比如说 querySelectorAll 是很多现代浏览器都支持的原生 Web API，</span><br><span class="line">但是有些古老的浏览器并不支持，那么假设有人写了一段代码来实现这个功能.</span><br><span class="line">使这些浏览器也支持了这个功能，那么这就可以成为一个 Polyfill。</span><br></pre></td></tr></table></figure><h2 id="proxy的优势"><a href="#proxy的优势" class="headerlink" title="proxy的优势"></a>proxy的优势</h2><p>Proxy 与 Object.defineProperty 优劣对比</p><ol><li>响应式是惰性的。<br>在 Vue.js 2.x 中，对于一个深层属性嵌套的对象，要劫持它内部深层次的变化，就需要递归遍历这个对象，执行 Object.defineProperty 把每一层对象数据都变成响应式的，这无疑会有很大的性能消耗。<br>在 Vue.js 3.0 中，使用 Proxy API 并不能监听到对象内部深层次的属性变化，因此它的处理方式是在 getter 中去递归响应式，这样的好处是真正访问到的内部属性才会变成响应式，简单的可以说是按需实现响应式，减少性能消耗。</li><li>Proxy 有多达 13 种拦截方法,不限于 apply、ownKeys、deleteProperty、has 等等是 Object.defineProperty 不具备的</li></ol><h2 id="为什么要用-Proxy-替代-defineProperty-？"><a href="#为什么要用-Proxy-替代-defineProperty-？" class="headerlink" title="为什么要用 Proxy 替代 defineProperty ？"></a>为什么要用 Proxy 替代 defineProperty ？</h2><p>1.defineProperty API 的局限性最大原因是它只能针对单例属性做监听。<br>Vue2.x中的响应式实现正是基于defineProperty中的descriptor，对 data 中的属性做了遍历 + 递归，为每个属性设置了 getter、setter。这也就是为什么 Vue 只能对 data 中预定义过的属性做出响应的原因。<br>2.Proxy API的监听是针对一个对象的，那么对这个对象的所有操作会进入监听操作， 这就完全可以代理所有属性，将会带来很大的性能提升和更优的代码。<br>Proxy 可以理解成，在目标对象之前架设一层“拦截”，外界对该对象的访问，都必须先通过这层拦截，因此提供了一种机制，可以对外界的访问进行过滤和改写。</p><h2 id="mvvm和mvc的区别"><a href="#mvvm和mvc的区别" class="headerlink" title="mvvm和mvc的区别"></a>mvvm和mvc的区别</h2><p>这都是软件架构设计模式，主要通过分离关注点的方式来组织代码结构，优化开发效率。</p><ul><li><strong>mvc</strong>：MVC 通过分离 Model、View 和 Controller 的方式来组织代码结构。其中 View 负责页面的显示逻辑，Model 负责存储页面的业务数据，以及对相应数据的操作。Controller 层是 View 层和 Model 层的纽带，当用户与页面产生交互的时候，通过调用 Model 层，来完成对 Model 的修改，然后 Model 层再去通知 View 层更新。</li><li><strong>mvvm</strong>：Model代表数据模型，View代表UI视图，负责数据的展示；ViewModel负责监听Model中数据的改变并且控制视图的更新，处理用户交互操作；Model和View并无直接关联，而是通过ViewModel来进行联系的，Model和ViewModel之间有着双向数据绑定的联系。当Model中的数据改变时会触发View层的刷新，View中用户交互操作而改变的数据也会在Model中同步。<br>这种模式实现了 Model和View的数据自动同步，因此开发者只需要专注于数据的维护操作即可，而不需要自己操作DOM。<h2 id="computed和watch的区别"><a href="#computed和watch的区别" class="headerlink" title="computed和watch的区别"></a>computed和watch的区别</h2>对于Computed计算属性：</li><li>支持缓存，只有依赖的数据发生了变化，才会重新计算</li><li>不支持异步，当Computed中有异步操作时，无法监听数据的变化</li><li>如果一个属性是由其他属性计算而来的，这个属性依赖其他的属性，一般会使用computed</li><li>在computed中，属性有一个get方法和一个set方法，当数据发生变化时，会调用set方法。<br>对于watch侦听器：</li><li>它不支持缓存，数据变化时，它就会触发相应的操作</li><li>支持异步监听，第一个参数是最新的值，第二个是变化之前的值</li><li>监听数据必须是data中声明的或者父组件传递过来的props中的数据，当发生变化时，会触发其他操作，函数有两个的参数：<br>immediate：组件加载立即触发回调函数<br>deep：深度监听，发现数据内部的变化，在复杂数据类型中使用，例如数组中的对象发生变化。需要注意的是，deep无法监听到数组和对象内部的变化。<h2 id="v-if和v-show的区别"><a href="#v-if和v-show的区别" class="headerlink" title="v-if和v-show的区别"></a>v-if和v-show的区别</h2></li><li><strong>v-if是动态的向DOM树内添加或者删除DOM元素；v-show是通过设置DOM元素的display样式属性控制显隐；</strong></li><li>v-if会调用addIfCondition方法，生成vnode的时候会忽略对应节点，render的时候就不会渲染；</li><li>v-show会生成vnode，render的时候也会渲染成真实节点，只是在render过程中会在节点的属性中修改show属性值，也就是常说的display；</li><li><strong>v-if适合运营条件不大可能改变；v-show适合频繁切换</strong></li><li>v-if是惰性的，如果初始条件为假，则什么也不做；只有在条件第一次变为真时才开始局部编译; v-show是在任何条件下，无论首次条件是否为真，都被编译，然后被缓存，而且DOM元素保留；<h2 id="v-model-是如何实现的，语法糖实际是什么？"><a href="#v-model-是如何实现的，语法糖实际是什么？" class="headerlink" title="v-model 是如何实现的，语法糖实际是什么？"></a>v-model 是如何实现的，语法糖实际是什么？</h2>（1）作用在表单元素上 ： 给input绑定了v-on的value值，这个值指向了变量，并且在触发 input 事件的时候通过v-bind去动态把 message设置为目标值。<br>（2）作用在组件上 ：在自定义组件中，v-model 默认会利用名为 value 的 prop和名为 input 的事件<br>本质是一个父子组件通信的语法糖，通过prop和$.emit实现。<h2 id="data为什么是一个函数而不是对象"><a href="#data为什么是一个函数而不是对象" class="headerlink" title="data为什么是一个函数而不是对象"></a>data为什么是一个函数而不是对象</h2>在vue中，我们想要实现组件的复用，那就需要每个组件有自己的私有数据，而不互相干扰。<br>数据以函数返回值的形式定义，这样当每次复用组件的时候，就会返回一个新的data，也就是说每个组件都有自己的私有数据空间，它们各自维护自己的数据，不会干扰其他组件的正常运行。<br>如果是一个对象的话，当多个实例引用同一个对象时，只要一个实例对这个对象进行操作，其他实例中的数据也会发生变化，就会造成混乱难以维护。</li></ul><p><strong>除此之外：</strong><br>1.根实例对象data可以是对象也可以是函数（根实例是单例），不会产生数据污染情况。<br>2.组件实例对象data必须为函数，<strong>目的是为了防止多个组件实例对象之间共用一个data，产生数据污染。</strong>采用函数的形式，initData时会将其作为工厂函数都会返回全新data对象。<br>在源码中，自定义组件会进入mergeOptions进行选项合并，进入if判断，若data类型不是function，则出现警告提示。</p><h2 id="说说你对vue的理解"><a href="#说说你对vue的理解" class="headerlink" title="说说你对vue的理解"></a><a href="https://mp.weixin.qq.com/s?__biz=MzU1OTgxNDQ1Nw==&mid=2247484101&idx=1&sn=83b0983f0fca7d7c556e4cb0bff8c9b8&chksm=fc10c093cb674985ef3bd2966f66fc28c5eb70b0037e4be1af4bf54fb6fa9571985abd31d52f&scene=21#wechat_redirect">说说你对vue的理解</a></h2><h2 id="为什么Vue中的v-if和v-for不建议一起用"><a href="#为什么Vue中的v-if和v-for不建议一起用" class="headerlink" title="为什么Vue中的v-if和v-for不建议一起用?"></a>为什么Vue中的v-if和v-for不建议一起用?</h2><p>作用：</p><ul><li>v-if 指令用于条件性地渲染一块内容。这块内容只会在指令的表达式返回 true值的时候被渲染</li><li>v-for 指令基于一个数组来渲染一个列表。v-for 指令需要使用 item in items 形式的特殊语法，其中 items 是源数据数组或者对象，而 item 则是被迭代的数组元素的别名</li><li>在 v-for 的时候，建议设置key值，并且保证每个key值是独一无二的，这便于diff算法进行优化</li><li>从源码里面可以看到v-for的优先级大于v-if<h2 id="那两个都想用怎么办"><a href="#那两个都想用怎么办" class="headerlink" title="那两个都想用怎么办?"></a>那两个都想用怎么办?</h2></li><li>永远不要把 v-if 和 v-for 同时用在同一个元素上，带来性能方面的浪费（每次渲染都会先循环再进行条件判断）</li><li>如果避免出现这种情况，则在外层嵌套template（页面渲染不生成dom节点），在这一层进行v-if判断，然后在内部进行v-for循环。</li><li> 如果条件出现在循环内部，可通过计算属性computed提前过滤掉那些不需要显示的项<h2 id="为什么vue采用异步渲染"><a href="#为什么vue采用异步渲染" class="headerlink" title="为什么vue采用异步渲染"></a>为什么vue采用异步渲染</h2>vue是组件级更新，如果不采用异步更新，那么每次更新数据都会对当前组件进行重新渲染，所以为了性能，Vue会在本轮数据更新后，再异步更新视图，核心思想是nextTick。<br>比如我们修改this.message三次，我们真正想要的其实只是最后一次更新而已，也就是说前三次​​DOM​​​更新都是可以省略的，我们只需要等所有状态都修改好了之后再进行渲染就可以减少一些性能损耗。</li></ul><p><strong>这种在缓冲时去除重复数据对于避免不必要的计算和 DOM 操作是非常重要的。</strong></p><h2 id="子组件可以直接改变父组件的数据吗？"><a href="#子组件可以直接改变父组件的数据吗？" class="headerlink" title="子组件可以直接改变父组件的数据吗？"></a>子组件可以直接改变父组件的数据吗？</h2><ul><li><strong>不可以，为了维护父子组件的单向数据</strong>每次父级组件发生更新时，子组件中所有的 prop 都将会刷新为最新的值。如果这样做了，Vue 会在浏览器的控制台中发出警告。</li><li> 只能通过 $emit 派发一个自定义事件，父组件接收到后，由父组件修改。<h2 id="vue和react有什么区别？"><a href="#vue和react有什么区别？" class="headerlink" title="vue和react有什么区别？"></a>vue和react有什么区别？</h2></li><li><strong>数据监听的方式</strong>。Vue 通过 getter/setter 以及一些函数的劫持，能精确知道数据变化，不需要特别的优化就能达到很好的性能。React 默认是通过比较引用的方式进行的，如果不优化（PureComponent/shouldComponentUpdate）可能导致大量不必要的vDOM的重新渲染。这是因为 Vue 使用的是可变数据，而React更强调数据的不可变。</li><li><strong>模板渲染方式</strong>Vue鼓励写近似常规HTML的模板。写起来很接近标准 HTML元素，只是多了一些属性。React推荐你所有的模板通用JavaScript的语法扩展——JSX书写。不引入新的概念。</li><li><strong>数据流不同</strong>。vue是响应式的数据双向绑定系统，而react是单向数据流，没有双向绑定。</li><li><strong>组件通信方式</strong>父组件通过 props 向子组件传递数据或者回调，虽然可以传递回调，但是我们一般只传数据，而通过事件的机制来处理子组件向父组件的通信。子组件通过 事件 向父组件发送消息。通过 V2.2.0 中新增的 provide/inject 来实现父组件向子组件注入数据，可以跨越多个层级。在React中，父组件通过 props 可以向子组件传递数据或者回调，可以通过 context 进行跨层级的通信 ，这其实和 provide/inject 起到的作用差不多。<br>React 本身并不支持自定义事件 ，Vue中子组件向父组件传递消息有两种方式： 事件和回调函数，而且Vue更倾向于使用事件 。但是 在 React 中我们都是使用回调函数的 ，这可能是他们二者最大的区别。</li><li><strong>虚拟dom和diff算法</strong>。Vue基于snabbdom库，它有较好的速度以及模块机制。 Vue Diff使用双向链表，边对比，边更新DOM 。React主要使用 diff队列保存需要更新哪些DOM，得到patch树，再统一操作批量更新DOM。<h2 id="组件通信的方式"><a href="#组件通信的方式" class="headerlink" title="组件通信的方式"></a>组件通信的方式</h2>根据组件之间关系讨论组件通信最为清晰有效：<br>父子组件<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">props/$emit/$parent/ref/$attrs</span><br></pre></td></tr></table></figure>兄弟组件<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$parent/$root/eventbus/vuex</span><br></pre></td></tr></table></figure></li></ul><p>跨层级关系</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">eventbus/vuex/provide+inject</span><br></pre></td></tr></table></figure><h2 id="vue的生命周期？"><a href="#vue的生命周期？" class="headerlink" title="vue的生命周期？"></a>vue的生命周期？</h2><p>Vue 实例从创建到销毁的过程，就是生命周期。也就是从开始创建、初始化数据、编译模板、挂载DOM-渲染、更新-渲染、卸载等一系列的过程，我们称这是 Vue 的生命周期。</p><ul><li>第一次页面加载会触发哪几个钩子？<br>beforeCreate ， created ， beforeMount ，mounted </li><li>简述每个周期具体适合哪些场景？</li></ul><p><strong>beforeCreate</strong>：创建前，此阶段为实例初始化之后，this指向创建的实例，可以在这加个loading事件。<br><strong>created</strong>：创建后，此阶段为实例已经创建，完成数据（data、props、computed）的初始化导入依赖项<br><strong>beforeMount</strong>：挂载前，虽然得不到具体的DOM元素，但vue挂载的根节点已经创建，下面vue对DOM的操作将围绕这个根元素继续进行。<br><strong>mounted：</strong>挂载，完成创建vm.$el，和双向绑定，完成挂载DOM和渲染，可在mounted钩子函数中对挂载的DOM进行操作。可在这发起后端请求，拿回数据，配合路由钩子做一些事情。<br><strong>beforeUpdate</strong>：数据更新前，数据驱动DOM。可在更新前访问现有的DOM，如手动移出添加的事件监听器。<br><strong>updated</strong>：数据更新后，完成虚拟DOM的重新渲染和打补丁。<br>组件DOM已完成更新，可执行依赖的DOM操作</p><h2 id="kepp-alive的理解，如何实现呢？"><a href="#kepp-alive的理解，如何实现呢？" class="headerlink" title="kepp-alive的理解，如何实现呢？"></a>kepp-alive的理解，如何实现呢？</h2><p><strong>keep-alive有以下三个属性：</strong></p><ul><li>include 字符串或正则表达式，只有名称匹配的组件会被匹配；</li><li> exclude 字符串或正则表达式，任何名称匹配的组件都不会被缓存；</li><li>max 数字，最多可以缓存多少组件实例。</li></ul><p><strong>实现步骤：</strong></p><ul><li>获取 keep-alive 下第一个子组件的实例对象，通过他去获取这个组件的组件名</li><li> 通过当前组件名去匹配原来 include 和exclude，判断当前组件是否需要缓存，不需要缓存，直接返回当前组件的实例vNode</li><li>需要缓存，判断他当前是否在缓存数组里面：</li><li>存在，则将他原来位置上的 key 给移除，同时将这个组件的 key 放到数组最后面（LRU） </li><li>不存在，将组件 key放入数组，然后判断当前 key数组是否超过 max 所设置的范围，超过，那么削减未使用时间最长的一个组件的 key</li><li>最后将这个组件的keepAlive 设置为 true</li><li>其核心思想是 “如果数据最近被访问过，那么将来被访问的几率也更高”。<h2 id="nexTtick的原理及作用"><a href="#nexTtick的原理及作用" class="headerlink" title="$nexTtick的原理及作用"></a>$nexTtick的原理及作用</h2></li><li>nextTick 的核心是利用了如 Promise 、MutationObserver、setImmediate、setTimeout的原生 JavaScript 方法来模拟对应的微/宏任务的实现，本质是为了利用 JavaScript 的这些异步回调任务队列来实现 Vue 框架中自己的异步回调队列。</li><li>Vue采用了数据驱动视图的思想，但是在一些情况下，仍然需要操作DOM。有时候，可能遇到这样的情况，DOM1的数据发生了变化，而DOM2需要从DOM1中获取数据，那这时就会发现DOM2的视图并没有更新，这时就需要用到了nextTick了。</li></ul><p><strong>所以，在以下情况下，会用到nextTick：</strong></p><ol><li>在数据变化后执行的某个操作，而这个操作需要使用随数据变化而变化的DOM结构的时候，这个操作就需要方法在nextTick()的回调函数中。</li><li>在vue生命周期中，如果在created()钩子进行DOM操作，也一定要放在nextTick()的回调函数中。</li></ol><p>因为在created()钩子函数中，页面的DOM还未渲染，这时候也没办法操作DOM，所以，此时如果想要操作DOM，必须将操作的代码放在nextTick()的回调函数中。</p><h2 id="vue的性能优化有哪些"><a href="#vue的性能优化有哪些" class="headerlink" title="vue的性能优化有哪些"></a>vue的性能优化有哪些</h2><p><strong>（1）编码阶段</strong></p><blockquote><p>尽量减少data中的数据，data中的数据都会增加getter和setter，会收集对应的watcher v-if和v-for不能连用<br>如果需要使用v-for给每项元素绑定事件时使用事件代理 SPA 页面采用keep-alive缓存组件<br>在更多的情况下，使用v-if替代v-show key保证唯一 使用路由懒加载、异步组件 防抖、节流 第三方模块按需导入<br>长列表滚动到可视区域动态加载 图片懒加载</p></blockquote><p><strong>（2）SEO优化</strong></p><blockquote><p>预渲染 服务端渲染SSR</p></blockquote><p><strong>（3）打包优化</strong></p><blockquote><p>压缩代码 Tree Shaking/Scope Hoisting 使用cdn加载第三方模块 多线程打包happypack<br>splitChunks抽离公共文件 sourceMap优化</p></blockquote><h2 id="对前端路由的理解"><a href="#对前端路由的理解" class="headerlink" title="对前端路由的理解"></a>对前端路由的理解</h2><ul><li>在前端技术早期，一个 url 对应一个页面，如果要从 A 页面切换到 B 页面，那么必然伴随着页面的刷新。</li><li>Ajax 出现了，它允许人们在不刷新页面的情况下发起请求，在这样的背景下，出现了 SPA（单页面应用）。</li><li>但是在 SPA 诞生之初，人们并没有考虑到“定位”这个问题——在内容切换前后，页面的 URL 都是一样的，这就带来了两个问题：<br>只要刷新一下页面，一切就会被清零，必须重复之前的操作、才可以重新对内容进行定位——SPA 并不会“记住”你的操作。<br>由于有且仅有一个 URL 给页面做映射，这对 SEO 也不够友好，搜索引擎无法收集全面的信息。</li><li>拦截用户的刷新操作，避免服务端盲目响应、返回不符合预期的资源内容。把刷新这个动作完全放到前端逻辑里消化掉。</li><li> 感知url的变化，不是改造url。一旦我们感知到了，我们就根据这些变化、用 JS 去给它生成不同的内容。<h2 id="Vue-router-导航守卫有哪些"><a href="#Vue-router-导航守卫有哪些" class="headerlink" title="Vue-router 导航守卫有哪些"></a>Vue-router 导航守卫有哪些</h2>全局前置/钩子：beforeEach、beforeResolve、afterEach<br>路由独享的守卫：beforeEnter<br>组件内的守卫：beforeRouteEnter、beforeRouteUpdate、beforeRouteLeave<h2 id="route-和-router-的区别"><a href="#route-和-router-的区别" class="headerlink" title="$route 和$router 的区别"></a><code>$route 和$router</code> 的区别</h2></li><li>$route 是“路由信息对象”，包括 path，params，hash，query，fullPath，matched，name<br>等路由信息参数</li><li>$router 是“路由实例”对象包括了路由的跳转方法，钩子函数等。<h2 id="路由的hash和history模式的区别"><a href="#路由的hash和history模式的区别" class="headerlink" title="路由的hash和history模式的区别"></a>路由的hash和history模式的区别</h2></li></ul><p><strong>hash：</strong><br> hash模式是开发中默认的模式，它的URL带着一个#。hash值会出现在URL里面，但是不会出现在HTTP请求中，对后端完全没有影响。所以改变hash值，不会重新加载页面。低版本的IE浏览器也支持这种模式，<br><strong>原理：</strong> hash模式的主要原理就是onhashchange()事件：使用onhashchange()事件的好处就是，在页面的hash值发生变化时，无需向后端发起请求，window就可以监听事件的改变，并按规则加载相应的代码。<br><strong>history：</strong><br> history模式的URL中没有#，它使用的是传统的路由分发模式，即用户在输入一个URL时，服务器会接收这个请求，并解析这个URL，然后做出相应的逻辑处理。<br><strong>特点：</strong> 当使用history模式时。相比hash模式更加好看。但是，history模式需要后台配置支持。如果后台没有正确配置，访问时会返回404。修改历史状态：包括了 HTML5 History Interface 中新增的 pushState() 和 replaceState() 方法，这两个方法应用于浏览器的历史记录栈，提供了对历史记录进行修改的功能。</p><p> <strong>两种模式对比</strong><br>调用 history.pushState() 相比于直接修改 hash，存在以下优势:</p><ol><li>pushState() 设置的新 URL 可以是与当前 URL 同源的任意 URL；而 hash 只可修改 # 后面的部分，因此只能设置与当前 URL 同文档的 URL；</li><li>pushState() 设置的新 URL 可以与当前 URL 一模一样，这样也会把记录添加到栈中；而 hash 设置的新值必须与原来不一样才会触发动作将记录添加到栈中；</li><li>pushState() 通过 stateObject 参数可以添加任意类型的数据到记录中；而 hash 只可添加短字符串；</li><li>hash模式下，仅hash符号之前的url会被包含在请求中，后端如果没有做到对路由的全覆盖，也不会返回404错误；history模式下，前端的url必须和实际向后端发起请求的url一致，如果没有对用的路由处理，将返回404错误。</li></ol><p>hash模式和history模式都有各自的优势和缺陷，还是要根据实际情况选择性的使用。</p>]]></content>
      
      
      <categories>
          
          <category> vue </category>
          
      </categories>
      
      
        <tags>
            
            <tag> web前端 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>小柚智汇——web开发规范</title>
      <link href="/2022/11/19/post/"/>
      <url>/2022/11/19/post/</url>
      
        <content type="html"><![CDATA[<h2 id="小柚智汇——web开发规范"><a href="#小柚智汇——web开发规范" class="headerlink" title="小柚智汇——web开发规范"></a>小柚智汇——web开发规范</h2><h2 id="1-为什么要做这件事"><a href="#1-为什么要做这件事" class="headerlink" title="1.为什么要做这件事"></a>1.为什么要做这件事</h2><h3 id="1-现实意义"><a href="#1-现实意义" class="headerlink" title="1.现实意义"></a>1.现实意义</h3><ul><li>提高团队的协作能力</li><li>提高代码的重复利用率</li><li>可以写出质量更高，效率更好的代码</li><li>为后期维护提供更好的支持</li></ul><h3 id="2-基本准则"><a href="#2-基本准则" class="headerlink" title="2.基本准则"></a>2.基本准则</h3><ul><li>符合web标准，结构表现行为分离，兼容性优良．页面性能方面，代码要求简洁明了有序，尽可能的减小服务器负载,保证最快的解析速度.</li><li>项目的维护和二次开发可能是直接或间接的团队合作,所以创建易维护的代码是一个项目成功与否的关键，易维护的代码意味着具有如下特性:</li><li>阅读性好:如良好的注释和命名规范，有文档</li><li>具有一致性:看起来如同一个人编写</li><li>代码的松耦合，高度模块化:将页面内的元素视为一个个模块，相互独立，尽量避免耦合过高的代码，从html,css,js.三个层面都要考虑模块化</li><li>严格按照规范编写代码</li></ul><h2 id="2-HTML规范"><a href="#2-HTML规范" class="headerlink" title="2.HTML规范"></a>2.HTML规范</h2><h3 id="1-命名规则"><a href="#1-命名规则" class="headerlink" title="1.命名规则"></a>1.命名规则</h3><h4 id="1-文件名称命名规则："><a href="#1-文件名称命名规则：" class="headerlink" title="1.文件名称命名规则："></a>1.文件名称命名规则：</h4><blockquote><h3 id="统一用小写的英文字母，数字和下划线的组合，不得包含汉字空格和特殊字符。"><a href="#统一用小写的英文字母，数字和下划线的组合，不得包含汉字空格和特殊字符。" class="headerlink" title="统一用小写的英文字母，数字和下划线的组合，不得包含汉字空格和特殊字符。"></a>统一用小写的英文字母，数字和下划线的组合，不得包含汉字空格和特殊字符。</h3></blockquote><p><strong>命名的原则</strong>：</p><p>​        1.方便理解 </p><p>​        2.方便查找。当我们在文件夹中使用?按名称排例?的命令时,同.种太类的文件能够排列在一起，以便我们查找修改、替换、计算负载量等等操作。</p><h4 id="2-索引文件命名原则："><a href="#2-索引文件命名原则：" class="headerlink" title="2.索引文件命名原则："></a>2.索引文件命名原则：</h4><blockquote><p>​    index.htm ||  index.asp || index.jsp</p></blockquote><h4 id="3-各子页面命名原则："><a href="#3-各子页面命名原则：" class="headerlink" title="3.各子页面命名原则："></a>3.各子页面命名原则：</h4><ul><li>统一用翻译的英文命名</li><li>统一用拼音命名</li><li>不要英语拼音混用</li></ul><h3 id="2-代码规范-盒子嵌套"><a href="#2-代码规范-盒子嵌套" class="headerlink" title="2.代码规范(盒子嵌套)"></a>2.代码规范(盒子嵌套)</h3><ol><li><p>块级元素和块级元素平级，内嵌元素与内嵌元素平级.</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;div&gt;&lt;span&gt;&lt;/span&gt;&lt;/div&gt;  // span是行内元素， p是块级元素，所以这是个错误的嵌套</span><br></pre></td></tr></table></figure></li><li><p>块元素可以包含内联元素或某些块元素，但内联元素不能包含块元素，它只能包含其它的内联元素(a链接除外)</p></li><li><p>有几个特殊的块级元素只能包含内嵌元素，不能再包含块级元素,h1、h2、h3、h4、h5、h6、p</p></li></ol><h2 id="3-CSS规范"><a href="#3-CSS规范" class="headerlink" title="3.CSS规范"></a>3.CSS规范</h2><h3 id="1-注释"><a href="#1-注释" class="headerlink" title="1.注释"></a>1.注释</h3><h4 id="1-文件注释"><a href="#1-文件注释" class="headerlink" title="1.文件注释"></a>1.文件注释</h4><p>文件顶部必须包含文件注释，用@name标识文件说明。星号要一列对齐，星号与内容之间必须保留一个空格，标识符冒号与内容之间必须保留一个空格。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* <span class="doctag">@name</span>:文件名或模块名</span></span><br><span class="line"><span class="comment">* <span class="doctag">@description</span>: 文件或模块描述</span></span><br><span class="line"><span class="comment">* <span class="doctag">@author</span>: mark（11）</span></span><br><span class="line"><span class="comment">*          郭闯(22)</span></span><br><span class="line"><span class="comment">* <span class="doctag">@update</span>: 2022-02-22 00:02</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>当该业务项目主要由固定的一个或多个人负责时，需要添加@author标识，一方面是尊重劳动成果，另一方面方便在需要时快速定位责任人。  </p><h4 id="2-代码注释"><a href="#2-代码注释" class="headerlink" title="2.代码注释"></a>2.代码注释</h4><ul><li>单行注释  星号与内容之间必须保留一个空格</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/* 表格隔行变色 */</span><br></pre></td></tr></table></figure><ul><li><p>多行注释 星号要一列对齐，星号与内容之间必须保留一个空格</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">* sometimes you need to include optional context for the entire component.do that up here if is important enough.</span><br><span class="line">*/</span><br></pre></td></tr></table></figure></li></ul><h3 id="2编码规范"><a href="#2编码规范" class="headerlink" title="2编码规范"></a>2编码规范</h3><h4 id="1-class盒子规范"><a href="#1-class盒子规范" class="headerlink" title="1.class盒子规范"></a>1.class盒子规范</h4><p>1.布局:以g为命名空间，例如:-g-wrap、-g-header、.g-content。<br>2.状态:以s 为命名空间，表示动态的、具有交互性质的状态，例如:.s-current、s-selected。<br>3.工具:以u为命名空间，表示不耦合业务逻辑的、可复用的的工具，例如: u-clearfix、u-ellipsis。<br>4.组件:以m为命名空间，表示可复用、移植的组件模块，例如:m-slider、m-dropMenu。<br>5.钩子:以j为命名空间，表示特定给JavaScript调用的类名，例如:j-request、j-open。</p><h4 id="2-css书写顺序"><a href="#2-css书写顺序" class="headerlink" title="2.css书写顺序"></a>2.css书写顺序</h4><p>1.位置属性(position,top, right, z-index,display,float等)<br>2.大小(width, height, padding, margin)<br>3.文字系列(font, line-height, letter-spacing,color-text-align等)<br>4.背景(background, border等)5.其他(animation, transition等)</p><h4 id="3-缩写"><a href="#3-缩写" class="headerlink" title="3.缩写"></a>3.缩写</h4><p>使用css缩写属性，css有些属性是可以缩写的，比如padding,margin, font等等，这样精简代码同时又能提高用户的阅读体验。</p><h4 id="4-去掉小数点前的“0”"><a href="#4-去掉小数点前的“0”" class="headerlink" title="4.去掉小数点前的“0”"></a>4.去掉小数点前的“0”</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">font-size: .8em;</span><br></pre></td></tr></table></figure><h4 id="5-连字符CSS选择器命名规范"><a href="#5-连字符CSS选择器命名规范" class="headerlink" title="5.连字符CSS选择器命名规范"></a>5.连字符CSS选择器命名规范</h4><p><em>1.长名称或词组可以使用中横线来为选择器命名。</em><br>2.不建议使用 “_”  下划线来命名css选择器，为什么呢?<br>输入的时候少按一个shift键;<br>浏览器兼容问题</p><p><em>(比如使用tips 的选择器命名，在IE6是无效的)能良好区分JavaScript变量命名（JS变量命名是用”_”)</em></p><h4 id="6-选择器"><a href="#6-选择器" class="headerlink" title="6.选择器"></a>6.选择器</h4><p>当一个规则包含多个选择器时，每个选择器独占一行。</p><h2 id="4-JS规范"><a href="#4-JS规范" class="headerlink" title="4.JS规范"></a>4.JS规范</h2><h3 id="1-注释规范"><a href="#1-注释规范" class="headerlink" title="1.注释规范"></a>1.注释规范</h3><p>为代码编写注释是非常重要的.通常人们在深入思考一个问题时，会非常清楚这段代码的工作原理.但是当过一周后再次回到该代码时，可能会花上很长时间来回想起那段代码到底是干什么的.</p><ul><li><p>公共组件维护者和各栏目WD都需要在文件头部加上注释说明</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">*文件用途说明</span><br><span class="line">*作者姓名，联系方式</span><br><span class="line">*制作日期</span><br><span class="line">**/   </span><br></pre></td></tr></table></figure></li><li><p>大的模块注释方法：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">//=============</span><br><span class="line">//  代码用途</span><br><span class="line">//=============</span><br></pre></td></tr></table></figure></li><li><p>小的注释</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">// 代码说明</span><br></pre></td></tr></table></figure></li></ul><h3 id="2-变量命名规范"><a href="#2-变量命名规范" class="headerlink" title="2.变量命名规范"></a>2.变量命名规范</h3><p>​    数组:a开头 ||  布尔:b开头 ||  函数:f开头 ||  数值:n开头 ||  对象:o开头 ||  字符串:s开头 || 正则: r开头</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> aChange = []</span><br></pre></td></tr></table></figure><p><strong>变量命名例子</strong><br>        为什么需要这样强制定义变量前缀? 正式因为javascript是<strong>弱语言</strong>造成的.在定义大量变量的时候，我们需要很明确的知道当前变量是什么属性，如果只通过普通单词，是很难区分的.</p><p><strong>普通代码</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> checked = <span class="literal">false</span>;<span class="keyword">var</span> check = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">if</span>(check)&#123;<span class="comment">//已经无法很确切知道这里是要用checked还是 check()从而导致逻辑错误</span></span><br><span class="line"> <span class="comment">// do some thing</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>规范后代码</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> bChecked = <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">var</span> fnCheck = <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(bChecked) &#123;</span><br><span class="line"><span class="comment">// do some thing</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(<span class="title function_">fnCheck</span>()) &#123;</span><br><span class="line"><span class="comment">// do other thing</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>对象方法与事件响应函数:</strong> 对象方法命名使用  fn+对象类名+动词+名词形式;</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">fnAddressGetEmail</span>()<span class="comment">// 举例</span></span><br></pre></td></tr></table></figure><p><strong>事件响应函数</strong>:fn+触发事件对象名+事件名或者模块名称;</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">fnDivClick</span>() ; <span class="title function_">fnAddressSumbmitButtonClick</span>();</span><br></pre></td></tr></table></figure><p>**普通函数:**首字母小写，驼峰式命名，统一使用动词或者动词+名词形式</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">例如: fnGetVersion()，fnSubmitForm()，fnInit();</span><br></pre></td></tr></table></figure><p>涉及返回逻辑值的函数可以使用is, has,contains等表示逻辑的词语代替动词:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">例如: fnlsObject(), fnHasClass() , fnContainsElment().</span><br></pre></td></tr></table></figure><p>**内部函数:**使用_fn+动词+名词形式，内部函数必需在函数最后定义.<br>例如:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">fnGetNumber</span>(<span class="params">nTotal</span>) &#123;</span><br><span class="line"><span class="keyword">if</span> (nTotal &lt; <span class="number">100</span>) &#123;</span><br><span class="line">nTotal = <span class="number">100</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="title function_">_fnAdd</span>(ntotal);</span><br><span class="line">    <span class="keyword">function</span> <span class="title function_">_fnAdd</span>(<span class="params">nNumber</span>) &#123;</span><br><span class="line">nNumber++;</span><br><span class="line"><span class="keyword">return</span> nNumber;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="5-图片规范"><a href="#5-图片规范" class="headerlink" title="5.图片规范"></a>5.图片规范</h2><ol><li>所有页面元素类资片均放入img文件夹,测i试用图片放于img/demoimg文件夹</li><li>图片格式仅限于gif ll png ll jpg;</li><li>命名全部用小写英文字母||数字||的组合,其中不得包含汉字||空格||特殊字符﹔尽里用易懂的词汇，便于团队其他成员理解;命名分头尾两部分，用下划线隔开，比如ad_left01.gif ll btn_submit.gf;</li><li>在保证视觉效果的情况下选择最小的图片格式与图片质里,以减少加载时间;</li><li>尽里避免使用半透明的 png图片(若使用,请参考css,规范相关说明);</li><li>运用ss sprite技术集中小的背景图或图标,减小页面http请求，但注意。请务必在对应的sprite nsd源图中划愆考线,并保存至img目录下.</li></ol><h2 id="6-个人建议"><a href="#6-个人建议" class="headerlink" title="6.个人建议"></a>6.个人建议</h2><ol><li>开发过程中严格分工完成页面，以提高css重用率，避免重复</li><li>减小沉冗代码，书写所有人都可以看的懂的代码.</li><li>简洁易懂是一种美德.为用户着想,为服务器着想.</li></ol><h2 id="7-总结"><a href="#7-总结" class="headerlink" title="7.总结"></a>7.总结</h2><p>统一规范的最根本目的是为了保证团队成员的一致性，从而减少沟通成本，提高开发效率。</p><p><strong>前端规范会不断变化，我只写了部分基础的规范，基于自学学习的深化和公司实习的经历，后续会不断改进文章。</strong></p><blockquote><p>学会热爱标准，但要确保它们不是一成不变的。</p></blockquote><p><em>文章参考和推荐：</em></p>]]></content>
      
      
      <categories>
          
          <category> web </category>
          
      </categories>
      
      
        <tags>
            
            <tag> web前端 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>mark的fisrt page</title>
      <link href="/2022/11/15/hello-world/"/>
      <url>/2022/11/15/hello-world/</url>
      
        <content type="html"><![CDATA[<h2 id="这是我的第一篇文章-我相信所有的努力源于一个勇敢的开始"><a href="#这是我的第一篇文章-我相信所有的努力源于一个勇敢的开始" class="headerlink" title="这是我的第一篇文章.我相信所有的努力源于一个勇敢的开始"></a>这是我的第一篇文章.我相信所有的努力源于一个勇敢的开始</h2>]]></content>
      
      
      <categories>
          
          <category> 杂谈 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>第三篇文章</title>
      <link href="/2022/11/15/%E7%AC%AC%E4%B8%89%E7%AF%87%E6%96%87%E7%AB%A0/"/>
      <url>/2022/11/15/%E7%AC%AC%E4%B8%89%E7%AF%87%E6%96%87%E7%AB%A0/</url>
      
        <content type="html"><![CDATA[<h2 id="这是我的第三篇文章-我相信所有的努力源于一个勇敢的开始"><a href="#这是我的第三篇文章-我相信所有的努力源于一个勇敢的开始" class="headerlink" title="这是我的第三篇文章.我相信所有的努力源于一个勇敢的开始"></a>这是我的第三篇文章.我相信所有的努力源于一个勇敢的开始</h2>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>JS基础复习</title>
      <link href="/2022/11/15/%E7%AC%AC%E5%9B%9B%E7%AF%87%E6%96%87%E7%AB%A0/"/>
      <url>/2022/11/15/%E7%AC%AC%E5%9B%9B%E7%AF%87%E6%96%87%E7%AB%A0/</url>
      
        <content type="html"><![CDATA[<h3 id="JavaScript有哪些数据类型，它们的区别？"><a href="#JavaScript有哪些数据类型，它们的区别？" class="headerlink" title="JavaScript有哪些数据类型，它们的区别？"></a>JavaScript有哪些数据类型，它们的区别？</h3><p> Undefined、Null、Boolean、Number、String、Object、Symbol、BigInt</p><ul><li><p>Symbol独一无二不可变，解决全局变量冲突</p></li><li><p>BigInt任意精度，安全存储大整数</p></li><li><p>堆栈存放数据类型不一样</p></li><li><p>栈的占据空间小，大小固定，被频繁使用</p></li><li><p>堆的占据空间大、大小不固定。</p><h1 id="如何使用BigInt"><a href="#如何使用BigInt" class="headerlink" title="如何使用BigInt"></a>如何使用BigInt</h1><ol><li>可以用在一个整数字面量后面加 n 的方式定义一个 BigInt ，如：10n，</li><li>或者调用构造函数 BigInt()（不能使用 new 运算符）并传递一个<em>整数值或字符串值</em>。</li></ol></li></ul><h3 id="数据类型检测的方式有哪些"><a href="#数据类型检测的方式有哪些" class="headerlink" title="数据类型检测的方式有哪些"></a>数据类型检测的方式有哪些</h3><ul><li>typeof</li><li>instanceof</li><li>constructor</li><li>Object.prototype.toString.call()</li></ul><h3 id="obj-toString-的结果和Object-prototype-toString-call-obj-的结果不一样，这是为什么？"><a href="#obj-toString-的结果和Object-prototype-toString-call-obj-的结果不一样，这是为什么？" class="headerlink" title="obj.toString()的结果和Object.prototype.toString.call(obj)的结果不一样，这是为什么？"></a>obj.toString()的结果和Object.prototype.toString.call(obj)的结果不一样，这是为什么？</h3><p>toString是Object的原型方法，而Array、function等<strong>类型作为Object的实例，都重写了toString方法</strong>。</p><h3 id="reflect"><a href="#reflect" class="headerlink" title="reflect"></a>reflect</h3><p>Reflect 是一个内置的对象，它提供拦截 JavaScript 操作的方法，是 ES6 为了操作对象而提供的新 API。<br>Reflect不是一个函数对象，因此它是不可构造的。<br>Reflect的所有属性和方法都是静态的。</p><p>意义<br>现阶段，某些方法同时在Object和Reflect对象上部署，未来的新方法将只部署在Reflect对象上。<br>修改某些Object方法的返回结果，让其变得更规范化。如Object.defineProperty(obj, name, desc)在无法定义属性时，会抛出一个错误，而Reflect.defineProperty(obj, name, desc)则会返回false。<br>让Object操作都变成函数行为。<br>Reflect对象的方法与Proxy对象的方法一一对应，只要是Proxy对象的方法，就能在Reflect对象上找到对应的方法。</p><h1 id="JSON-parse-JSON-stringify-obj"><a href="#JSON-parse-JSON-stringify-obj" class="headerlink" title="JSON.parse(JSON.stringify(obj))"></a>JSON.parse(JSON.stringify(obj))</h1><p>1、如果obj里面有时间对象，则JSON.stringify后再JSON.parse的结果，时间将只是字符串的形式。而不是时间对象；</p><p>2、如果obj里有RegExp、Error对象，则序列化的结果将只得到空对象；</p><p>3、如果obj里有函数，undefined，则序列化的结果会把函数或 undefined丢失；</p><p>4、如果obj里有NaN、Infinity和-Infinity，则序列化的结果会变成null</p><p>5、JSON.stringify()只能序列化对象的可枚举的自有属性，例如 如果obj中的对象是有构造函数生成的，  则使用JSON.parse(JSON.stringify(obj))深拷贝后，会丢弃对象的constructor；</p><p>6、如果对象中存在循环引用的情况也无法正确实现深拷贝；</p><h3 id="判断数组的方式有哪些"><a href="#判断数组的方式有哪些" class="headerlink" title="判断数组的方式有哪些"></a>判断数组的方式有哪些</h3><ul><li>通过Object.prototype.toString.call()做判断</li><li>通过原型链做判断</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">obj.__proto__ === Array.prototype;</span><br></pre></td></tr></table></figure><ul><li><p>通过ES6的Array.isArray()做判断</p></li><li><p>通过instanceof做判断</p></li><li><p>通过Array.prototype.isPrototypeOf</p></li></ul><h3 id="null和undefined区别"><a href="#null和undefined区别" class="headerlink" title="null和undefined区别"></a>null和undefined区别</h3><p>undefined 代表的含义是<strong>未定义</strong>，null 代表的含义是<strong>空对象</strong>。</p><p>undefined一般给基本类型做未赋值   null一般给对象做未赋值</p><p>undefined是声明之后的默认值</p><p>undefined不是关键字， null是关键字</p><h3 id="typeof-null-的结果是什么，为什么？"><a href="#typeof-null-的结果是什么，为什么？" class="headerlink" title="typeof null 的结果是什么，为什么？"></a>typeof null 的结果是什么，为什么？</h3><p>Object</p><p>有两种特殊数据类型：</p><ul><li>undefined的值是 (-2)30(一个超出整数范围的数字)；</li><li>null 的值是机器码 NULL 指针(null 指针的值全是 0)</li></ul><p>那也就是说null的类型标签也是000，和Object的类型标签一样，所以会被判定为Object</p><h3 id="intanceof-操作符的实现原理及实现"><a href="#intanceof-操作符的实现原理及实现" class="headerlink" title="intanceof 操作符的实现原理及实现"></a>intanceof 操作符的实现原理及实现</h3><p>用于判断构造函数的 prototype 属性是否出现在对象的原型链中。</p><h3 id="为什么0-1-0-2-0-3，如何让其相等"><a href="#为什么0-1-0-2-0-3，如何让其相等" class="headerlink" title="为什么0.1+0.2 ! == 0.3，如何让其相等"></a>为什么0.1+0.2 ! == 0.3，如何让其相等</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(n1 + n2).toFixed(2) // 注意，toFixed为四舍五入</span><br></pre></td></tr></table></figure><p>一般我们认为数字包括整数和小数，但是在 JavaScript 中只有一种数字类型：Number，它的实现遵循IEEE 754标准，使用64位固定长度来表示，也就是标准的double双精度浮点数。在二进制科学表示法中，双精度浮点数的小数部分最多只能保留52位，再加上前面的1，其实就是保留53位有效数字，剩余的需要舍去，遵从“0舍1入”的原则。</p><p>根据这个原则，0.1和0.2的二进制数相加，再转化为十进制数就是：<code>0.30000000000000004</code></p><h3 id="typeof-NaN-的结果是什么？"><a href="#typeof-NaN-的结果是什么？" class="headerlink" title="typeof NaN 的结果是什么？"></a>typeof NaN 的结果是什么？</h3><p>NaN 是一个特殊值，它和自身不相等，是唯一一个非自反（自反，reflexive，即 x === x 不成立）的值。而 NaN !== NaN 为 true。  <strong>Number</strong></p><h3 id="isNaN-和-Number-isNaN-函数的区别？"><a href="#isNaN-和-Number-isNaN-函数的区别？" class="headerlink" title="isNaN 和 Number.isNaN 函数的区别？"></a>isNaN 和 Number.isNaN 函数的区别？</h3><p>isNaN 接收参数后，会将这个参数转换为数值，任何不能被转换为数值都会返回 true，非数字值传入也会返回 true ，会影响 NaN 的判断。</p><h3 id="和-amp-amp-操作符的返回值？"><a href="#和-amp-amp-操作符的返回值？" class="headerlink" title="|| 和 &amp;&amp; 操作符的返回值？"></a>|| 和 &amp;&amp; 操作符的返回值？</h3><ul><li>对于 || 来说，如果条件判断结果为 true 就返回第一个操作数的值，如果为 false 就返回第二个操作数的值。</li><li>&amp;&amp; 则相反，如果条件判断结果为 true 就返回第二个操作数的值，如果为 false 就返回第一个操作数的值。</li></ul><h3 id="Object-is-与比较操作符-“-”、“-”-的区别？"><a href="#Object-is-与比较操作符-“-”、“-”-的区别？" class="headerlink" title="Object.is() 与比较操作符 “===”、“==” 的区别？"></a>Object.is() 与比较操作符 “===”、“==” 的区别？</h3><ul><li>使用 Object.is 来进行相等判断时，一般情况下和三等号的判断相同，它处理了一些特殊的情况，比如 -0 和 +0 不再相等，两个 NaN 是相等的。</li></ul><h3 id="什么是-JavaScript-中的包装类型？"><a href="#什么是-JavaScript-中的包装类型？" class="headerlink" title="什么是 JavaScript 中的包装类型？"></a>什么是 JavaScript 中的包装类型？</h3><p>在调用基本类型的属性或方法时 JavaScript 会在后台隐式地将基本类型的值转换为对象</p><ul><li>使用<code>Object</code>函数显式地将基本类型转换为包装类型</li><li>使用<code>valueOf</code>方法将包装类型倒转成基本类型</li></ul><h3 id="JavaScript-中如何进行隐式类型转换？"><a href="#JavaScript-中如何进行隐式类型转换？" class="headerlink" title="JavaScript 中如何进行隐式类型转换？"></a>JavaScript 中如何进行隐式类型转换？</h3><p>首先要介绍<code>ToPrimitive</code>方法，这是 JavaScript 中每个值隐含的自带的方法，用来将值 （无论是基本类型值还是对象）转换为基本类型值。</p><h3 id="为什么会有BigInt的提案？"><a href="#为什么会有BigInt的提案？" class="headerlink" title="为什么会有BigInt的提案？"></a>为什么会有<strong>BigInt</strong>的提案？</h3><p>JavaScript中Number.MAX_SAFE_INTEGER表示最⼤安全数字，计算结果是9007199254740991，即在这个数范围内不会出现精度丢失（⼩数除外）</p><h3 id="object-assign和扩展运算法是深拷贝还是浅拷贝，两者区别"><a href="#object-assign和扩展运算法是深拷贝还是浅拷贝，两者区别" class="headerlink" title="object.assign和扩展运算法是深拷贝还是浅拷贝，两者区别"></a>object.assign和扩展运算法是深拷贝还是浅拷贝，两者区别</h3><p><strong><em>*<code>Object.assign()</code>*</em> 方法用于将所有可枚举属性的值从一个或多个源对象分配到目标对象。它将返回目标对象。</strong></p><p>Object.assign()方法接收的第一个参数作为目标对象，后面的所有参数作为源对象。然后把所有的源对象合并到目标对象中。它会修改了一个对象，因此会触发 ES6 setter。</p><p>扩展操作符（…）使用它时，数组或对象中的每一个值都会被拷贝到一个新的数组或对象中。它不复制继承的属性或类的属性，但是它会复制ES6的 symbols 属性。</p><h3 id="let、const、var的区别"><a href="#let、const、var的区别" class="headerlink" title="let、const、var的区别"></a>let、const、var的区别</h3><p><strong>块级作用域</strong></p><p><strong>变量提升</strong></p><p><strong>重复声明</strong></p><p>**暂时性死区 ** 当程序的控制流程在新的作用域（module function 或 block<br>作用域）进行实例化时，在此作用域中用let/const声明的变量会先在作用域中被创建出来，但因此时还未进行词法绑定，所以是不能被访问的，如果访问就会抛出错误。因此，在这运行流程进入作用域创建变量，到变量可以被访问之间的这一段时间，就称之为暂时死区。</p><p><strong>初始值设置</strong></p><h3 id="const对象的属性可以修改吗？"><a href="#const对象的属性可以修改吗？" class="headerlink" title="const对象的属性可以修改吗？"></a>const对象的属性可以修改吗？</h3><p>const保证的并不是变量的值不能改动，而是变量指向的那个内存地址不能改动。对于基本类型的数据（数值、字符串、布尔值），其值就保存在变量指向的那个内存地址，因此等同于常量。</p><p>使用Object.freeze(obj)冻结obj，就能使其内部的属性不可变，但有局限，就是obj对象中要是有属性是对象，该对象内属性还能改变，要全不可变的话，就需要使用递归等方式一层一层全部冻结。</p><p><strong>Object.preventExtensions(obj) / Object.isExtensible(obj)</strong></p><p>功能：使某一对象不可扩展，也就是不能为其添加新属性。</p><h3 id="如果new一个箭头函数的会怎么样"><a href="#如果new一个箭头函数的会怎么样" class="headerlink" title="如果new一个箭头函数的会怎么样"></a>如果new一个箭头函数的会怎么样</h3><p>箭头函数是ES6中的提出来的，它没有prototype，也没有自己的this指向，更不可以使用arguments参数，所以不能New一个箭头函数。</p><p>Arguments是个类似数组但不是数组的对象，说他类似数组是因为其具备数组相同的访问性质及方式，能够由arguments[n]来访问对应的单个参数的值，并拥有数组长度属性length。还有就是arguments对象存储的是实际 传递给函数的参数，而不局限于函数声明所定义的参数列表，而且不能显式创建 arguments 对象。</p><h3 id="箭头函数与普通函数的区别"><a href="#箭头函数与普通函数的区别" class="headerlink" title="箭头函数与普通函数的区别"></a>箭头函数与普通函数的区别</h3><p><strong>箭头函数比普通函数更加简洁</strong></p><p><strong>箭头函数没有自己的this</strong></p><p><strong>箭头函数继承来的this指向永远不会改变</strong></p><h3 id="Proxy-可以实现什么功能？"><a href="#Proxy-可以实现什么功能？" class="headerlink" title="Proxy 可以实现什么功能？"></a>Proxy 可以实现什么功能？</h3><p>后来ES6规范中的箭头函数里面的this是在定义它时绑定的，指向它的父级作用域，而不是调用它对象</p><p>之所以 Vue3.0 要使用 <code>Proxy</code> 替换原本的 API 原因在于 <code>Proxy</code> 无需一层层递归为每个属性添加代理，一次即可完成以上操作，性能上更好，并且原本的实现有一些数据更新不能监听到，但是 <code>Proxy</code> 可以完美监听到任何方式的数据改变，唯一缺陷就是浏览器的兼容性不好。</p><h3 id="如何提取高度嵌套的对象里的指定属性？"><a href="#如何提取高度嵌套的对象里的指定属性？" class="headerlink" title="如何提取高度嵌套的对象里的指定属性？"></a><strong>如何提取高度嵌套的对象里的指定属性？</strong></h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">const &#123; classes: &#123; stu: &#123; name &#125; &#125;&#125; = school</span><br><span class="line">       </span><br><span class="line">console.log(name)  // &#x27;Bob&#x27;</span><br></pre></td></tr></table></figure><h3 id="对-rest-参数的理解"><a href="#对-rest-参数的理解" class="headerlink" title="对 rest 参数的理解"></a>对 rest 参数的理解</h3><p>它可以把函数的多个入参收敛进一个数组里。这一点<strong>经常用于获取函数的多余参数，或者像上面这样处理函数参数个数不确定的情况。</strong></p><h3 id="介绍-js-有哪些内置对象？"><a href="#介绍-js-有哪些内置对象？" class="headerlink" title="介绍 js 有哪些内置对象？"></a>介绍 js 有哪些内置对象？</h3><p>值属性</p><p>函数属性</p><p>基本对象</p><p>JavaScript有3大对象，分别是<code>本地对象</code>、<code>内置对象</code>和<code>宿主对象</code>。</p><p>本地对象：</p><ul><li>这些引用类型在运行过程中需要通过new来创建所需的实例对象。</li><li>包含：<code>Object</code>、<code>Array</code>、<code>Date</code>、<code>RegExp</code>、<code>Function</code>、<code>Boolean</code>、<code>Number</code>、<code>String</code>等。</li></ul><p>内置对象：</p><ul><li>内置对象是本地对象的子集。</li><li>包含：<code>Global</code>和<code>Math</code>。</li><li>ECMAScript5中增添了<code>JSON</code>这个存在于全局的内置对象。</li></ul><p>宿主对象：</p><ul><li>对于嵌入到网页中的JS来说，其宿主对象就是浏览器提供的对象，浏览器对象有很多，如<code>Window</code>和<code>Document</code>等。</li><li>所有的<code>DOM</code>和<code>BOM</code>对象都属于宿主对象。</li></ul><h3 id="谈谈对原型链的理解"><a href="#谈谈对原型链的理解" class="headerlink" title="谈谈对原型链的理解"></a>谈谈对原型链的理解</h3><p>​        在 js 中我们是使用构造函数来新建一个对象的，每一个构造函数的内部都有一个 prototype 属性值，这个属性值是一个对 象，这个对象包含了可以由该构造函数的所有实例共享的属性和方法。当我们使用构造函数新建一个对象后，在这个对象的内部 将包含一个指针，这个指针指向构造函数的 prototype 属性对应的值，在 ES5 中这个指针被称为对象的原型。一般来说我们 是不应该能够获取到这个值的，但是现在浏览器中都实现了 <strong>proto</strong> 属性来让我们访问这个属性，但是我们最好不要使用这 个属性，因为它不是规范中规定的。ES5 中新增了一个 Object.getPrototypeOf() 方法，我们可以通过这个方法来获取对 象的原型。</p><p>​        当我们访问一个对象的属性时，如果这个对象内部不存在这个属性，那么它就会去它的原型对象里找这个属性，这个原型对象又 会有自己的原型，于是就这样一直找下去，也就是原型链的概念。</p><h3 id="js-获取原型的方法？"><a href="#js-获取原型的方法？" class="headerlink" title="js 获取原型的方法？"></a>js 获取原型的方法？</h3><ul><li>p.<strong>proto</strong></li><li>p.constructor.prototype</li><li>Object.getPrototypeOf(p)</li></ul><h3 id="for-in-和for-of"><a href="#for-in-和for-of" class="headerlink" title="for in 和for of"></a>for in 和for of</h3><p>forin</p><p><code>for...in</code> 语句以任意顺序遍历一个对象的除 <code>Symbol</code> 以外的可<a href="https://so.csdn.net/so/search?q=%E6%9E%9A%E4%B8%BE&spm=1001.2101.3001.7020">枚举</a>属性，包括继承的可枚举属性。</p><p><code>for...in</code> 是为遍历对象属性而构建的，不建议与数组一起使用。</p><p>在处理有 <code>key-value</code> 数据，也就是获取键值。</p><p>使用 <code>for in</code> 去遍历数组，得到的 <code>key</code> 是数组的索引 <code>index</code>。</p><p>在 <code>for in</code> 中可以使用 <code>break</code> 或者 <code>continue</code> 去中断循环，不可以用 <code>return</code> 去中断循环</p><p>forof</p><p>for of无法循环遍历对象 ，for in循环遍历的是数组的键值(索引)，而for of循环遍历的是数组的值。</p><h4 id="for-in遍历数组的毛病"><a href="#for-in遍历数组的毛病" class="headerlink" title="for in遍历数组的毛病"></a>for in遍历数组的毛病</h4><p>1.index索引为字符串型数字，不能直接进行几何运算<br>2.遍历顺序有可能不是按照实际数组的内部顺序<br>3.使用for in会遍历数组所有的可枚举属性，包括原型。例如上栗的原型方法method和name属性<br>所以for in更适合遍历对象，不要使用for in遍历数组。</p><h3 id="遍历对象的方法"><a href="#遍历对象的方法" class="headerlink" title="遍历对象的方法"></a>遍历对象的方法</h3><ul><li>for in</li><li>Object.keys()</li><li>Reflect.ownKey()</li><li>Object.getOwnProertyName()</li></ul><h3 id="关于Object和Map的区别"><a href="#关于Object和Map的区别" class="headerlink" title="关于Object和Map的区别"></a>关于Object和Map的区别</h3><p>共同点： 键值对的动态集合，支持增加和删除键值对</p><p>1.构造方式           </p><p>2.键的类型（object会强制转换为string或symbol）（map的特例是NaN）            </p><p>3.键的顺序   （key是无序的，Object.getOwnPropertySymbols方法输出symbol）（key会按照添加的顺序返回）         </p><p>4.键值对size （只能手动计算，通过Object.keys()）（直接通过size属性访问）</p><p>5.键值对的访问  （map有一系列完整的操作api）      </p><p>6.迭代器 （object本身不具有Iterator特性，默认情况下不能使用for…of进行遍历）              7.JSON序列号 （map不能直接序列化：JSON.stringfy(Array.from(map2))）      </p><p>8.应用场景</p><p>Object :</p><p>1.仅做数据存储,并且属性仅为字符串或者Symbol</p><p>2需要进行序列化转换为json传输时</p><p>3.当做一个对象的实例,需要保留自己的属性和方法时</p><p>Map</p><p>1.会频繁更新和删除键值对时</p><p><strong>2.存储大量数据时,尤其是key类型未知的情况下</strong></p><p>3.需要频繁进行迭代处理</p><h3 id="常见的类数组转换为数组的方法有这样几种："><a href="#常见的类数组转换为数组的方法有这样几种：" class="headerlink" title="常见的类数组转换为数组的方法有这样几种："></a>常见的类数组转换为数组的方法有这样几种：</h3><p>（1）通过 call 调用数组的 slice 方法来实现转换</p><p>（2）通过 call 调用数组的 splice 方法来实现转换</p><p>（3）通过 apply 调用数组的 concat 方法来实现转换</p><p>（4）通过 Array.from 方法来实现转换</p><h3 id="Unicode、UTF-8、UTF-16、UTF-32有什么区别？"><a href="#Unicode、UTF-8、UTF-16、UTF-32有什么区别？" class="headerlink" title="Unicode、UTF-8、UTF-16、UTF-32有什么区别？"></a><strong>Unicode、UTF-8、UTF-16、UTF-32有什么区别？</strong></h3><p><code>Unicode</code> 是编码字符集（字符集），而<code>UTF-8</code>、<code>UTF-16</code>、<code>UTF-32</code>是字符集编码</p><ul><li>如果字符内容全部英文或英文与其他文字混合，但英文占绝大部分，那么用<code>UTF-8</code>就比<code>UTF-16</code>节省了很多空间；而如果字符内容全部是中文这样类似的字符或者混合字符中中文占绝大多数，那么<code>UTF-16</code>就占优势了，可以节省很多空间；</li></ul><h3 id="对AJAX的理解，实现一个AJAX请求"><a href="#对AJAX的理解，实现一个AJAX请求" class="headerlink" title="对AJAX的理解，实现一个AJAX请求"></a>对AJAX的理解，实现一个AJAX请求</h3><p>AJAX是 Asynchronous JavaScript and XML 的缩写，指的是通过 JavaScript 的 异步通信，从服务器获取 XML 文档从中提取数据，再更新当前网页的对应部分，而不用刷新整个网页。</p><p>1.创建一个XMLHttpRequest对象</p><p>2.open</p><p>3.onreadystatechange</p><p>4.readystate, responseText</p><h3 id="ES6模块与CommonJS模块有什么异同？"><a href="#ES6模块与CommonJS模块有什么异同？" class="headerlink" title="ES6模块与CommonJS模块有什么异同？"></a><strong>ES6</strong>模块与<strong>CommonJS</strong>模块有什么异同？</h3><p>1.CommmonJS是运行时加载，es6是编译时输出</p><p>2.commonjs输出的是值的拷贝，es6输出的是值的引用</p><p>3.commonjs中this指向当前模块，es6指向undefined</p><h3 id="常见的DOM操作有哪些"><a href="#常见的DOM操作有哪些" class="headerlink" title="常见的DOM操作有哪些"></a>常见的DOM操作有哪些</h3><p>第一种方式，使用 instanceof 运算符来判断构造函数的 prototype 属性是否出现在对象的原型链中的任何位置。</p><p>第二种方式，通过对象的 constructor 属性来判断，对象的 constructor 属性指向该对象的构造函数，但是这种方式不是很安全，因为 constructor 属性可以被改写。</p><p>第三种方式，如果需要判断的是某个内置的引用类型的话，可以使用 Object.prototype.toString() 方法来打印对象的[[Class]] 属性来进行判断。</p><h3 id="解释性语言和编译型语言的区别"><a href="#解释性语言和编译型语言的区别" class="headerlink" title="解释性语言和编译型语言的区别"></a>解释性语言和编译型语言的区别</h3><p><strong>两者主要区别在于：</strong> 前者源程序编译后即可在该平台运行，后者是在运行期间才编译。所以前者运行速度快，后者跨平台性好。</p><h3 id="for…in和for…of的区别"><a href="#for…in和for…of的区别" class="headerlink" title="for…in和for…of的区别"></a>for…in和for…of的区别</h3><p>for…of 是ES6新增的遍历方式</p><ul><li>for…in 获取的是对象的键名，for…of 遍历获取的是对象的键值</li><li>for… in 会遍历对象的整个原型链，而 for … of 只遍历当前对象不会遍历原型链；</li><li>for…in 循环主要是为了遍历对象而生，for…of 循环可以用来遍历数组、类数组对象，字符串、Set、Map 以及 Generator 对象。</li></ul><h3 id="如何使用for…of遍历对象"><a href="#如何使用for…of遍历对象" class="headerlink" title="如何使用for…of遍历对象"></a>如何使用for…of遍历对象</h3><p>for…of是作为ES6新增的遍历方式，允许遍历一个含有iterator接口的数据结构（数组、对象等）并且返回各项的值，普通的对象用for..of遍历是会报错的。</p><p>如果需要遍历的对象是类数组对象，用Array.from转成数组即可。</p><p>如果不是类数组对象，就给对象添加一个[Symbol.iterator]属性，并指向一个迭代器即可。</p><h4 id="fetch不是ajax的进一步封装，而是原生js，没有使用XMLHttpRequest对象。"><a href="#fetch不是ajax的进一步封装，而是原生js，没有使用XMLHttpRequest对象。" class="headerlink" title="fetch不是ajax的进一步封装，而是原生js，没有使用XMLHttpRequest对象。"></a><strong>fetch不是ajax的进一步封装，而是原生js，没有使用XMLHttpRequest对象</strong>。</h4><h4 id="使用后hasOwnProperty-方法来判断属性是否属于原型链的属性"><a href="#使用后hasOwnProperty-方法来判断属性是否属于原型链的属性" class="headerlink" title="使用后hasOwnProperty()方法来判断属性是否属于原型链的属性"></a>使用后<code>hasOwnProperty()</code>方法来判断属性是否属于原型链的属性</h4><h3 id="对闭包的理解"><a href="#对闭包的理解" class="headerlink" title="对闭包的理解"></a>对闭包的理解</h3><p><strong>闭包是指有权访问另一个函数作用域中变量的函数</strong>，创建闭包的最常见的方式就是在一个函数内创建另一个函数，创建的函数可以访问到当前函数的局部变量。</p><p>作用：使我们在函数外部能够访问到函数内部的变量。</p><p>​            使已经运行结束的函数上下文中的变量对象继续留在内存。</p><p>例子： 比如，函数 A 内部有一个函数 B，函数 B 可以访问到函数 A 中的变量，那么函数 B 就是闭包。</p><p>应用： 循环中使用闭包解决 var 定义函数的问题</p><h3 id="对作用域、作用域链的理解"><a href="#对作用域、作用域链的理解" class="headerlink" title="对作用域、作用域链的理解"></a>对作用域、作用域链的理解</h3><p><strong>作用域链：</strong> 在当前作用域中查找所需变量，但是该作用域没有这个变量，那这个变量就是自由变量。如果在自己作用域找不到该变量就去父级作用域查找，依次向上级作用域查找，直到访问到window对象就被终止，这一层层的关系就是作用域链。</p><p>作用域链的作用是<strong>保证对执行环境有权访问的所有变量和函数的有序访问，通过作用域链，可以访问到外层环境的变量和函数。</strong></p><h1 id="apply、call、bind-区别"><a href="#apply、call、bind-区别" class="headerlink" title="apply、call、bind 区别"></a>apply、call、bind 区别</h1><p>apply 和 call 基本类似，他们的区别只是传入的参数不同，自动调用函数。</p><p>bind 是创建一个新的函数，我们必须要手动去调用。</p><h3 id="对Promise的理解"><a href="#对Promise的理解" class="headerlink" title="对Promise的理解"></a>对Promise的理解</h3><p>所谓Promise，简单说就是一个容器，里面保存着某个未来才会结束的事件（通常是一个异步操作）的结果。从语法上说，Promise 是一个对象，从它可以获取异步操作的消息。</p><p>他的出现大大改善了异步编程的困境，避免了地狱回调，</p><p>Promise的实例有<strong>三个状态</strong>:</p><ul><li>Pending（进行中）</li><li>Resolved（已完成）</li><li>Rejected（已拒绝）</li></ul><p>一旦从进行状态变成为其他状态就永远不能更改状态了。</p><p><strong>Promise的特点：</strong></p><p>对象的状态不受外界影响。只有异步操作的结果，可以决定当前是哪一种状态。</p><p>一旦状态改变就不会再变，任何时候都可以得到这个结果。</p><p><strong>Promise的缺点：</strong></p><p>一旦新建它就会立即执行，无法中途取消。</p><p>如果不设置回调函数，Promise内部抛出的错误，不会反应到外部。</p><p>当处于pending状态时，无法得知目前进展到哪一个阶段</p><p><strong>在构造 <code>Promise</code> 的时候，构造函数内部的代码是立即执行的</strong></p><h4 id="Promise方法"><a href="#Promise方法" class="headerlink" title="Promise方法"></a>Promise方法</h4><p>Promise有五个常用的方法：then()、catch()、all()、race()、finally</p><p><strong>catch（）</strong></p><p>不过<code>catch</code>方法还有一个作用，就是在执行<code>resolve</code>回调函数时，如果出现错误，抛出异常，不会停止运行，而是进入<code>catch</code>方法中。</p><p><strong>all()</strong></p><p>它接收一个数组，数组的每一项都是一个<code>promise</code>对象。当数组中所有的<code>promise</code>的状态都达到<code>resolved</code>的时候，<code>all</code>方法的状态就会变成<code>resolved</code>，如果有一个状态变成了<code>rejected</code>，那么<code>all</code>方法的状态就会变成<code>rejected</code>。</p><p>Promise.all获得的成功结果的数组里面的数据顺序和Promise.all接收到的数组顺序是一致的，这样<strong>当遇到发送多个请求并根据请求顺序获取和使用数据的场景</strong>，就可以使用Promise.all来解决。</p><p><strong>race（）</strong></p><p>那么<code>race</code>方法有什么实际作用呢？当要做一件事，超过多长时间就不做了，可以用这个方法来解决：</p><h3 id="对async-await-的理解"><a href="#对async-await-的理解" class="headerlink" title="对async/await 的理解"></a>对async/await 的理解</h3><p>async/await其实是<code>Generator</code> 的语法糖，它能实现的效果都能用then链来实现，它是为优化then链而开发出来的。从字面上来看，async是“异步”的简写，await则为等待，所以很好理解async 用于申明一个 function 是异步的，而 await 用于等待一个异步方法执行完成。</p><h3 id="setTimeout、setInterval、requestAnimationFrame-各有什么特点？"><a href="#setTimeout、setInterval、requestAnimationFrame-各有什么特点？" class="headerlink" title="setTimeout、setInterval、requestAnimationFrame 各有什么特点？"></a>setTimeout、setInterval、requestAnimationFrame 各有什么特点？</h3><p><code>setInterval()</code> - 间隔指定的毫秒数不停地执行指定的代码（一直执行）。</p><p><code>setTimeout()</code> - 在指定的毫秒数后执行指定代码(只执行一次)。</p><h3 id="并发与并行的区别？"><a href="#并发与并行的区别？" class="headerlink" title="并发与并行的区别？"></a>并发与并行的区别？</h3><ul><li>并发是宏观概念，我分别有任务 A 和任务 B，在一段时间内通过任务间的切换完成了这两个任务，这种情况就可以称之为并发。</li><li>并行是微观概念，假设 CPU 中存在两个核心，那么我就可以同时完成任务 A、B。同时完成多个任务的情况就可以称之为并行。</li></ul><h3 id="浏览器的垃圾回收机制"><a href="#浏览器的垃圾回收机制" class="headerlink" title="浏览器的垃圾回收机制"></a>浏览器的垃圾回收机制</h3><p><strong>垃圾回收</strong>：JavaScript代码运行时，需要分配内存空间来储存变量和值。当变量不在参与运行时，就需要系统收回被占用的内存空间，这就是垃圾回收。</p><h4 id="垃圾回收的方式"><a href="#垃圾回收的方式" class="headerlink" title="垃圾回收的方式"></a>垃圾回收的方式</h4><ul><li>Javascript 具有自动垃圾回收机制，会定期对那些不再使用的变量、对象所占用的内存进行释放，原理就是找到不再使用的变量，然后释放掉其占用的内存。</li></ul><p> <strong>1）标记清除</strong></p><ul><li>标记清除是浏览器常见的垃圾回收方式，当变量进入执行环境时，就标记这个变量“进入环境”，被标记为“进入环境”的变量是不能被回收的，因为他们正在被使用。当变量离开环境时，就会被标记为“离开环境”，被标记为“离开环境”的变量会被内存释放。</li></ul><p><strong>2）引用计数</strong></p><p>引用计数就是跟踪记录每个值被引用的次数。当声明了一个变量并将一个引用类型赋值给该变量时，则这个值的引用次数就是1。相反，如果包含对这个值引用的变量又取得了另外一个值，则这个值的引用次数就减1。</p><h4 id="（3）减少垃圾回收"><a href="#（3）减少垃圾回收" class="headerlink" title="（3）减少垃圾回收"></a>（3）减少垃圾回收</h4><ul><li><p><strong>对</strong><code>object</code><strong>进行优化：</strong> 对象尽量复用，对于不再使用的对象，就将其设置为null，尽快被回收。</p></li><li><p><strong>对函数进行优化：</strong> 在循环中的函数表达式，如果可以复用，尽量放在函数的外面。</p></li><li><p><strong>对数组进行优化：</strong> 在清空一个数组时，最简单的方法就是给其赋值为[ ]，但是与此同时会创建一个新的空对象，可以将数组的长度设置为0，以此来达到清空数组的目的。</p></li></ul><h3 id="哪些情况会导致内存泄漏"><a href="#哪些情况会导致内存泄漏" class="headerlink" title="哪些情况会导致内存泄漏"></a>哪些情况会导致内存泄漏</h3><ul><li><p><strong>意外的全局变量：</strong> 由于使用未声明的变量，而意外的创建了一个全局变量，而使这个变量一直留在内存中无法被回收。</p></li><li><p><strong>被遗忘的计时器或回调函数：</strong> 设置了 setInterval 定时器，而忘记取消它，如果循环函数有对外部变量的引用的话，那么这个变量会被一直留在内存中，而无法被回收。</p></li><li><p><strong>脱离 DOM 的引用：</strong> 获取一个 DOM 元素的引用，而后面这个元素被删除，由于一直保留了对这个元素的引用，所以它也无法被回收。</p></li><li><p><strong>闭包：</strong> 不合理的使用闭包，从而导致某些变量一直被留在内存当中。</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> js </category>
          
      </categories>
      
      
        <tags>
            
            <tag> web前端 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
    
    
    <entry>
      <title>关于</title>
      <link href="/about/index.html"/>
      <url>/about/index.html</url>
      
        <content type="html"><![CDATA[<!-- git --><div id="gitZone"></div>]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>categories</title>
      <link href="/categories/index.html"/>
      <url>/categories/index.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/css/common.css"/>
      <url>/css/common.css</url>
      
        <content type="html"><![CDATA[/* 页脚与头图透明 */#footer {    background: transparent !important;  }  #page-header {    background: transparent !important;  }    /* 白天模式遮罩透明 */  #footer::before {    background: transparent !important;  }  #page-header::before {    background: transparent !important;  }    /* 夜间模式遮罩透明 */  [data-theme="dark"] #footer::before {    background: transparent !important;  }  [data-theme="dark"] #page-header::before {    background: transparent !important;  }  @font-face {    /* 为载入的字体取名字(随意) */    font-family: 'YSHST';    /* 字体文件地址(相对或者绝对路径都可以) */    src: url(/font/霞鹜文楷.woff2);    /* 定义加粗样式(加粗多少) */    font-weight: normal;    /* 定义字体样式(斜体/非斜体) */    font-style: normal;    /* 定义显示样式 */    font-display: block;  }  /* 翻页按钮居中 */#pagination {  width: 100%;  margin: auto;}/* 一级菜单居中 */#nav .menus_items {  position: absolute !important;  width: fit-content !important;  left: 50% !important;  transform: translateX(-50%) !important;}/* 子菜单横向展示 */#nav .menus_items .menus_item:hover .menus_item_child {  display: flex !important;}/* 这里的2是代表导航栏的第2个元素，即有子菜单的元素，可以按自己需求修改 */.menus_items .menus_item:nth-child(2) .menus_item_child {  left: -38px;}/* 夜间模式菜单栏发光字 */[data-theme="dark"] #nav .site-page,[data-theme="dark"] #nav .menus_items .menus_item .menus_item_child li a {  text-shadow: 0 0 2px #4ACA6D !important;}/* 手机端适配 */[data-theme="dark"] #sidebar #sidebar-menus .menus_items .site-page {  text-shadow: 0 0 2px #4ACA6D !important;}/* 背景宇宙星光  */#universe{  display: block;  position: fixed;  margin: 0;  padding: 0;  border: 0;  outline: 0;  left: 0;  top: 0;  width: 100%;  height: 100%;  pointer-events: none;  /* 这个是调置顶的优先级的，-1在文章页下面，背景上面，个人推荐这种 */  z-index: 1;}/* 侧边栏个人信息卡片动态渐变色 */#aside-content > .card-widget.card-info {  background: linear-gradient(    -45deg,    #e8d8b9,    #eccec5,    #a3e9eb,    #bdbdf0,    #eec1ea  );  box-shadow: 0 0 5px rgb(66, 68, 68);  position: relative;  background-size: 400% 400%;  -webkit-animation: Gradient 10s ease infinite;  -moz-animation: Gradient 10s ease infinite;  animation: Gradient 10s ease infinite !important;}@-webkit-keyframes Gradient {  0% {    background-position: 0% 50%;  }  50% {    background-position: 100% 50%;  }  100% {    background-position: 0% 50%;  }}@-moz-keyframes Gradient {  0% {    background-position: 0% 50%;  }  50% {    background-position: 100% 50%;  }  100% {    background-position: 0% 50%;  }}@keyframes Gradient {  0% {    background-position: 0% 50%;  }  50% {    background-position: 100% 50%;  }  100% {    background-position: 0% 50%;  }}/* 黑夜模式适配 */[data-theme="dark"] #aside-content > .card-widget.card-info {  background: #191919ee;}/* 个人信息Follow me按钮 */#aside-content > .card-widget.card-info > #card-info-btn {  background-color: #3eb8be;  border-radius: 8px;}body {  cursor:url(https://anzhiy.cn/img/x1.cur),        default;}a,img {  cursor:url(https://anzhiy.cn/img/x1.cur),        default;}.pace {  -webkit-pointer-events: none;  pointer-events: none;  -webkit-user-select: none;  -moz-user-select: none;  user-select: none;}.pace-inactive {  display: none;}.pace .pace-progress {  background: #e90f92;  position: fixed;  z-index: 2000;  top: 0;  right: 100%;  width: 100%;  height: 2px;}.pace .pace-progress-inner {  display: block;  position: absolute;  right: 0px;  width: 100px;  height: 100%;  box-shadow: 0 0 10px #e90f92, 0 0 5px #e90f92;  opacity: 1.0;  -webkit-transform: rotate(3deg) translate(0px, -4px);  -moz-transform: rotate(3deg) translate(0px, -4px);  -ms-transform: rotate(3deg) translate(0px, -4px);  -o-transform: rotate(3deg) translate(0px, -4px);  transform: rotate(3deg) translate(0px, -4px);}.pace .pace-activity {  display: block;  position: fixed;  z-index: 2000;  top: 15px;  right: 15px;  width: 14px;  height: 14px;  border: solid 2px transparent;  border-top-color: #e90f92;  border-left-color: #e90f92;  border-radius: 10px;  -webkit-animation: pace-spinner 400ms linear infinite;  -moz-animation: pace-spinner 400ms linear infinite;  -ms-animation: pace-spinner 400ms linear infinite;  -o-animation: pace-spinner 400ms linear infinite;  animation: pace-spinner 400ms linear infinite;}@-webkit-keyframes pace-spinner {  0% { -webkit-transform: rotate(0deg); transform: rotate(0deg); }  100% { -webkit-transform: rotate(360deg); transform: rotate(360deg); }}@-moz-keyframes pace-spinner {  0% { -moz-transform: rotate(0deg); transform: rotate(0deg); }  100% { -moz-transform: rotate(360deg); transform: rotate(360deg); }}@-o-keyframes pace-spinner {  0% { -o-transform: rotate(0deg); transform: rotate(0deg); }  100% { -o-transform: rotate(360deg); transform: rotate(360deg); }}@-ms-keyframes pace-spinner {  0% { -ms-transform: rotate(0deg); transform: rotate(0deg); }  100% { -ms-transform: rotate(360deg); transform: rotate(360deg); }}@keyframes pace-spinner {  0% { transform: rotate(0deg); transform: rotate(0deg); }  100% { transform: rotate(360deg); transform: rotate(360deg); }}/* 在下面修改进度条外观 */.pace .pace-progress {  background: #1ef4fbec; /*进度条颜色*/  height: 3px;/* 进度条厚度 */}.pace .pace-progress-inner {  box-shadow: 0 0 10px #1ef4fbce, 0 0 5px #1ecffbd0; /*阴影颜色*/}.pace .pace-activity {  border-top-color: #1edafbe5;/*上边框颜色*/  border-left-color: #1ef4fbec;/*左边框颜色*/}]]></content>
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/css/custom.css"/>
      <url>/css/custom.css</url>
      
        <content type="html"><![CDATA[:root {    --trans-light: rgba(255, 255, 255, 0.88);    --trans-dark: rgba(25, 25, 25, 0.88);    --border-style: 1px solid rgb(169, 169, 169);    --backdrop-filter: blur(5px) saturate(150%);  }    /* 首页文章卡片 */  #recent-posts > .recent-post-item {    background: var(--trans-light);    backdrop-filter: var(--backdrop-filter);    border-radius: 25px;    border: var(--border-style);  }    /* 首页侧栏卡片 */  #aside-content .card-widget {    background: var(--trans-light);    backdrop-filter: var(--backdrop-filter);    border-radius: 18px;    border: var(--border-style);  }    /* 文章页、归档页、普通页面 */  div#post,  div#page,  div#archive {    background: var(--trans-light);    backdrop-filter: var(--backdrop-filter);    border: var(--border-style);    border-radius: 20px;  }    /* 导航栏 */  #page-header.nav-fixed #nav {    background: rgba(255, 255, 255, 0.75);    backdrop-filter: var(--backdrop-filter);  }    [data-theme="dark"] #page-header.nav-fixed #nav {    background: rgba(0, 0, 0, 0.7) !important;  }    /* 夜间模式遮罩 */  [data-theme="dark"] #recent-posts > .recent-post-item,  [data-theme="dark"] #aside-content .card-widget,  [data-theme="dark"] div#post,  [data-theme="dark"] div#archive,  [data-theme="dark"] div#page {    background: var(--trans-dark);  }      /* 夜间模式页脚页头遮罩透明 */  [data-theme="dark"] #footer::before {    background: transparent !important;  }  [data-theme="dark"] #page-header::before {    background: transparent !important;  }    /* 阅读模式 */  .read-mode #aside-content .card-widget {    background: rgba(158, 204, 171, 0.5) !important;  }  .read-mode div#post {    background: rgba(158, 204, 171, 0.5) !important;  }    /* 夜间模式下的阅读模式 */  [data-theme="dark"] .read-mode #aside-content .card-widget {    background: rgba(25, 25, 25, 0.9) !important;    color: #ffffff;  }  [data-theme="dark"] .read-mode div#post {    background: rgba(25, 25, 25, 0.9) !important;    color: #ffffff;  }]]></content>
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/css/progress_bar.css"/>
      <url>/css/progress_bar.css</url>
      
        <content type="html"><![CDATA[.pace {    -webkit-pointer-events: none;    pointer-events: none;    -webkit-user-select: none;    -moz-user-select: none;    user-select: none;    z-index: 2000;    position: fixed;    margin: auto;    top: 4px;    left: 0;    right: 0;    height: 8px;    border-radius: 8px;    width: 7rem;    background: #eaecf2;    border: 1px #e3e8f7;    overflow: hidden}.pace-inactive .pace-progress {    opacity: 0;    transition: .3s ease-in}.pace .pace-progress {    -webkit-box-sizing: border-box;    -moz-box-sizing: border-box;    -ms-box-sizing: border-box;    -o-box-sizing: border-box;    box-sizing: border-box;    -webkit-transform: translate3d(0, 0, 0);    -moz-transform: translate3d(0, 0, 0);    -ms-transform: translate3d(0, 0, 0);    -o-transform: translate3d(0, 0, 0);    transform: translate3d(0, 0, 0);    max-width: 200px;    position: absolute;    z-index: 2000;    display: block;    top: 0;    right: 100%;    height: 100%;    width: 100%;    /* linear-gradient(to right, #3494e6, #ec6ead) */    background: linear-gradient(to right, #43cea2, #3866ca);    animation: gradient 2s ease infinite;    background-size: 200%}.pace.pace-inactive {    opacity: 0;    transition: .3s;    top: -8px}]]></content>
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/js/light.js"/>
      <url>/js/light.js</url>
      
        <content type="html"><![CDATA[// 霓虹灯效果// 颜色数组var arr = ["#39c5bb", "#f14747", "#f1a247", "#f1ee47", "#b347f1", "#1edbff", "#ed709b", "#5636ed"];// 颜色索引var idx = 0;// 切换颜色function changeColor() {    // 仅夜间模式才启用    if (document.getElementsByTagName('html')[0].getAttribute('data-theme') == 'dark') {        if (document.getElementById("site-name"))            document.getElementById("site-name").style.textShadow = arr[idx] + " 0 0 15px";        if (document.getElementById("site-title"))            document.getElementById("site-title").style.textShadow = arr[idx] + " 0 0 15px";        if (document.getElementById("site-subtitle"))            document.getElementById("site-subtitle").style.textShadow = arr[idx] + " 0 0 10px";        if (document.getElementById("post-info"))            document.getElementById("post-info").style.textShadow = arr[idx] + " 0 0 5px";        try {            document.getElementsByClassName("author-info__name")[0].style.textShadow = arr[idx] + " 0 0 12px";            document.getElementsByClassName("author-info__description")[0].style.textShadow = arr[idx] + " 0 0 12px";        } catch {                    }        idx++;        if (idx == 8) {            idx = 0;        }    } else {        // 白天模式恢复默认        if (document.getElementById("site-name"))            document.getElementById("site-name").style.textShadow = "#1e1e1ee0 1px 1px 1px";        if (document.getElementById("site-title"))            document.getElementById("site-title").style.textShadow = "#1e1e1ee0 1px 1px 1px";        if (document.getElementById("site-subtitle"))            document.getElementById("site-subtitle").style.textShadow = "#1e1e1ee0 1px 1px 1px";        if (document.getElementById("post-info"))            document.getElementById("post-info").style.textShadow = "#1e1e1ee0 1px 1px 1px";        try {            document.getElementsByClassName("author-info__name")[0].style.textShadow = "";            document.getElementsByClassName("author-info__description")[0].style.textShadow = "";        } catch {                    }    }}// 开启计时器window.onload = setInterval(changeColor, 1200);]]></content>
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/js/universe.js"/>
      <url>/js/universe.js</url>
      
        <content type="html"><![CDATA[function dark() {window.requestAnimationFrame=window.requestAnimationFrame||window.mozRequestAnimationFrame||window.webkitRequestAnimationFrame||window.msRequestAnimationFrame;var n,e,i,h,t=.05,s=document.getElementById("universe"),o=!0,a="180,184,240",r="226,225,142",d="226,225,224",c=[];function f(){n=window.innerWidth,e=window.innerHeight,i=.216*n,s.setAttribute("width",n),s.setAttribute("height",e)}function u(){h.clearRect(0,0,n,e);for(var t=c.length,i=0;i<t;i++){var s=c[i];s.move(),s.fadeIn(),s.fadeOut(),s.draw()}}function y(){this.reset=function(){this.giant=m(3),this.comet=!this.giant&&!o&&m(10),this.x=l(0,n-10),this.y=l(0,e),this.r=l(1.1,2.6),this.dx=l(t,6*t)+(this.comet+1-1)*t*l(50,120)+2*t,this.dy=-l(t,6*t)-(this.comet+1-1)*t*l(50,120),this.fadingOut=null,this.fadingIn=!0,this.opacity=0,this.opacityTresh=l(.2,1-.4*(this.comet+1-1)),this.do=l(5e-4,.002)+.001*(this.comet+1-1)},this.fadeIn=function(){this.fadingIn&&(this.fadingIn=!(this.opacity>this.opacityTresh),this.opacity+=this.do)},this.fadeOut=function(){this.fadingOut&&(this.fadingOut=!(this.opacity<0),this.opacity-=this.do/2,(this.x>n||this.y<0)&&(this.fadingOut=!1,this.reset()))},this.draw=function(){if(h.beginPath(),this.giant)h.fillStyle="rgba("+a+","+this.opacity+")",h.arc(this.x,this.y,2,0,2*Math.PI,!1);else if(this.comet){h.fillStyle="rgba("+d+","+this.opacity+")",h.arc(this.x,this.y,1.5,0,2*Math.PI,!1);for(var t=0;t<30;t++)h.fillStyle="rgba("+d+","+(this.opacity-this.opacity/20*t)+")",h.rect(this.x-this.dx/4*t,this.y-this.dy/4*t-2,2,2),h.fill()}else h.fillStyle="rgba("+r+","+this.opacity+")",h.rect(this.x,this.y,this.r,this.r);h.closePath(),h.fill()},this.move=function(){this.x+=this.dx,this.y+=this.dy,!1===this.fadingOut&&this.reset(),(this.x>n-n/4||this.y<0)&&(this.fadingOut=!0)},setTimeout(function(){o=!1},50)}function m(t){return Math.floor(1e3*Math.random())+1<10*t}function l(t,i){return Math.random()*(i-t)+t}f(),window.addEventListener("resize",f,!1),function(){h=s.getContext("2d");for(var t=0;t<i;t++)c[t]=new y,c[t].reset();u()}(),function t(){document.getElementsByTagName('html')[0].getAttribute('data-theme')=='dark'&&u(),window.requestAnimationFrame(t)}()};dark()]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>link</title>
      <link href="/link/index.html"/>
      <url>/link/index.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>电影</title>
      <link href="/movies/index.html"/>
      <url>/movies/index.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>音乐</title>
      <link href="/music/index.html"/>
      <url>/music/index.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>tags</title>
      <link href="/tags/index.html"/>
      <url>/tags/index.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
    </entry>
    
    
  
</search>
